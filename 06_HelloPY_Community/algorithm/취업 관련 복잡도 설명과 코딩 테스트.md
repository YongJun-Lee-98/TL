

Complexity(복잡도)  
알고리즘의 성능을 나타내는 척도

복잡도는 시간 복잡도와 공간복잡도로 나뉨

## 시간 복잡도
알고리즘을 위해 필요한 연산의 횟수

알고리즘 문제를 풀 때 단순히  
'복잡도'라고 하면 보통은 **시간** 복잡도를 의미  
코딩 테스트를 처음 시작할 때 난관이 **'시간제한'**  

코딩 테스트에서는 프로그램이 모든 입력 받고  
이를 처리하고 실행 결과를 출력하는 데까지 걸리는 시간을 의미함
해당 시간 안에 동작하는 프로그램을 작성해야 정답 판정을 받을 수 있으며, 프로그램을 비효율적으로 작성하여 시간 제한을 넘기면 '시간 초과'라는 메시지와 함께 오답으로 처리됨

시간 복잡도는 빅오 표기법을 사용함
빅오 표기법을 간단히 정의하면 가장 빠르게 증가하는 항만을 고려하는 표기법
함수의 상한만을 나타냄 
N개의 데이터가 있을 때 모든 데이터의 값을 더한 결과를 하나씩 확인하며 그 값을 합계 변수에 더해주는 식으로 알고리즘을 작성할 수 있음

시간 복잡도에 따라 부르는 명칭이 있는데 예를 들어 O(1)은 '상수시간', O(N)은 '선형시간'등으로 부른다.

| 빅오표기법    | 명칭                   |
| -------- | -------------------- |
| O(1)     | 상수시간 (Constant time) |
| O(logN)  | 로그 시간 (Log time)     |
| O(N)     | 선형 시간                |
| O(NlogN) | 로그 선형 시간             |
| O(N^2)   | 이차 시간                |
| O(N^3)   | 삼차 시간                |
| O(2^n)   | 지수 시간                |
이론적인 계산이 아닌, '실제 코딩 테스트'에서는 차수가 작은 항들을 오나전히 무시하는 것도 곤란함
연산횟수가 3N^3+5N^2+1,000,000인 알고리즘이 있다고 가정하면
빅오 표기법에서는 차수가 가장 큰 항만 남기기 때문에 O(N^3)으로 표기되지만, 실제로 N이 작을 때는 상수 값인 1,000,000이 미치는 영향력이 매우 큼 N = 10일때, 3N^3 + 5N^2 + 1,000,000 = 1,003,500이므로 상수의 영향이 크다. 일반적인 코딩 테스트에서는 상수를 고려해야 하는 경우는 적지만, 이처럼 빅오 표기법이 항상 절대적인 것은 아니란 점을 기억하자

컴퓨터 과학에서는 특정한 알고리즘의 시간 복잡도가 O(N^k)일 때 (k는 상수값)
이를 '다항 시간에 동작하는 알고리즘'이라고 말한다.
이차 시간, 삼차 시간 등이 모두 다항 시간에 해당한다.
이론적으로는 특정한 문제가 이러한 다항 시간 알고리즘으로 풀 수 있을 때 해당 알고리즘은 풀 만한 알고리즘으로 분류 되지만, 실제로는 그렇지 않다.
일반적으로 코딩 테스트 환경에서는 O(N^3)을 넘어가면 문제 풀이에서 사용하기 어렵다. 왜냐하면 CPU 기반의 개인 컴퓨터나 채점용 컴퓨터에서는 연산 횟수가 10억을 넘어가면 C언어를 기준으로 통상 1초 이상의 시간이 소요된다. 이때 N의 크기가 5,000이 넘는다면 족히 10초 이상이 시간이 걸릴 수 있다.
특히 파이썬은 더욱 오래걸리며, 코딩 테스트 문제에서 시간 제한은 1 ~ 5 초 가량이므로 보통 연산횟수가 10억을 넘어가도록 작성하면 오답 판정을 받을 수 있다.

각기 다른 시간 복잡도의 연산 횟수가 N의 크기에 따라서 어떻게 분포되는지 확인해보자
다음은 대략적인 연산 횟수를 비교한 표로 시간 복잡도가 동일하더라도 실제 연산 횟수에서는 차이가 날 수 있다.
시간 복잡도가 O(NlogN)인 알고리즘은 매우 다양하다.
빅오 표기법으로 표시한 시간 복잡도가 같더라도 알고리즘의 내부 로직 및 차수가 낮은 항의 영향에 따라 10,000번, 100,000번 등 실제 수행되는 연산 횟수는 다를 수 있다.

> 보통 시간 복잡도에서의 '연산'은 프로그래밍 언어에서 지원하는 사칙 연산 비교 연산 등과 같은 기본 연산을 의미함
> 예를 들어 두 정수 a와 b를 더하는 더하기 연산뿐만 아니라, 두 정수 a와 b의 값을 비교하는 비교 연산 또한 한 번의 연산으로 취급한다.

시간 복잡도 분석은 문제 풀이의 핵심이다.
알고리즘 문제 풀이에 능숙한 숙련자들은 문제를 해석하기 전에 조건을 먼저 보기도 한다.
문제의 조건부터 확인하면 문제를 풀기 위해 얼마나 효율적인 알고리즘을 작성해야 하는지 눈치 챌 수 있기 때문
예를 들어 데이터의 개수 N이 1,000만개를 넘어가면 시간 제한이 1초라면 대략 최악의 경우 O(N)의 시간 복잡도로 동작하는 알고리즘을 작성해야 할 것이라고 예상할 수 잇다. 혹은 데이터의 크기나 탐색 범위가 100억이나 1,000억을 넘어가는 경우 이후 6장에서 다룰  '이진탐색'과 같이 O(logN)의 시간 복잡도를 갖는 알고리즘을 자것ㅇ해야할 것임
실제로 알고리즘 대회 참가에 익숙한 사람들은 문제의 조건을 확인한 뒤에 사용할 수 있는 알고맂므을 좁혀 나가는 전략을 채택하기도 한다.

N의 범위가 500 인 경우 : 시간 복잡도가 O(N^3)인 알고리즘을 설계하면 문제를 풀 수 있다.
N의 범위가 2,000 인 경우 : 시간 복잡도가 O(N^2)인 알고리즘을 설계하면 문제를 풀 수 있다.
N의 범위가 100,000 인 경우 : 시간 복잡도가 O(NlogN)인 알고리즘을 설계하면 문제를 풀 수 있다.
N의 범위가 10,000,000 인 경우 : 시간 복잡도가 O(N)인 알고리즘을 설계하면 문제를 풀 수 있다.

## 공간 복잡도
알고리즘을 위해 필요한 메모리의 양

공간 복잡도를 표기할 때도 시간 복잡도를 표기했던 것처럼 빅오 표기법을 이용한다. 즉, 공간 복잡도 또한 O (NlogN), O(N^2)등으로 표기한다. 다만, 앞서 시간 복잡도에서 1초라는 절대적인 제한이 있던 것처럼, 메모리 사용량에도 절대적인 제한이 있다. 일반적으로 메모리 사용량 기준은 MB 단위로 제시됨
쉽게 말해 코딩 테스트 문제에서 보이는 시간 제한 1초, 메모리 제한 128MB와 같은 문장은 시간 복잡도와 공간 복잡도를 함께 제한하기 위하여 명시하는 것임
코딩 테스트 문제는 대부분 리스트(배열)를 사용해서 풀어야 한다.
대부분의 문제는 다수의 데이터에 대한 효율적인 처리를 요구하기 때문임
고전적인 프로그래밍 언어에서 정수형 자료형인 int를 기준으로 리스트 크기에 따른 메모리 사용량을 확인하기
실제로 컴퓨터 시스템에 차지하는 메모리양은 컴파일러에 따라 조금씩 따르게 적용될 수 있다.

int a\[1000] : 4KB
in a\[1000000] : 4MB
int a\[2000]\[2000] : 16MB
코딩 테스트에서는 보통 메모리 사용량을 128 ~ 512MB 정도로 제한한다.
다시 말해 일반적인 경우 데이터의 개수가 1,000만 단위가 넘어가지 않도록 알고리즘 설계를 해야 한다는 의미이다.
파이썬에서 int 자료형이 없지만, 파이썬에도 대략 100만 개 이상의 데이터가 들어갈 수 있는 크기의 리스트를 선언하는 경우는 적다는 점을 기억하자. 만약 리스트 크기가 1,000만 단위 이상이라면 자신이 알고리즘을 잘못 설계한 것이 아닌지 고민해보자

## 시간과 메모리 측정
파이썬에서 프로그램 수행 시간과 메모리 사용량을 측정할 수 있다. 알고리즘을 공부하는 과정에서 시간을 측정하는 작업을 굉장히 많이 사용한다. 실질적으로 알고리즘의 소요 시간을 확인해야 자신이 제대로 알고리즘으 ㄹ작성하고 있는지 체크할 수 있기 때문
다시 말해 실제 프로그램의 수행 시간을 측정하는 것은 알고리즘의 효율성을 측정하는 가장 기본적인 방법이다.
특정한 프로그램의 수행 시간을 측정하는 소스코드 예시는 다음과 같다.

```python
import time
start_time = time.time() # 측정 시작

# 프로그램 소스코드
end_time = time.time() # 측정 종료
print("time : ", end_time - start_time)
```
수행시간 측정 소스코드의 형태는 일반적으로 위와 같다.
보통 어떤 알고리즘을 설계한 뒤에 시간 복잡도를 경험적으로 증명하고 싶을 때는 위와 같은 형태의 코드를 자주 이용한다.
'선택 정렬'과 '파이썬의 기본 정렬 라이브러리'의 속도를 비교할 때는 다음쪽과 같이 소스코드를 작성할 수 있다.
선택 정렬을 사용할 때 최악의 경우 시간 복잡도가 O(N^2)이며, 파이썬의 기본 정렬 라이브러리는 최악의 경우 시간복잡도 O(NlogN)을 보장하여 상대적으로 빠르다.
다음 소스코드가 그러한 성능 차이를 직접적으로 보여준다.

실제로 매우 복잡한 문제에서는 정렬, 다이나믹 프로그래밍, 이진 탐색, 구현 등의 개념이 모두 사용되기도 한다.
문제를 해결하는 방법은 여러가지가 있기 때문에 해석하기에 따라서 다른 도표가 나올 수 있다.

구현 문제는 문법을 안다고 해서 쉽게 해결할 수 있는 문제는 아니다.
다양한 케이스를 고려해야 한정적으로 만점을 받을 수 있는 문제들이 주로 출제된다.

삼성전자 코테는 문제를 바르게 읽고 예외 상황을 적절히 처리하는 방식으로 소스코드를 작성하는 유형이 가장 많이 출제되었다는 후기가 많음 또한 문제 유형은 모든 상황을 고려해야 하는 완전 탐색 문제가 많이 출제되는 것으로 유명함 삼전은 DFS/BFS, 구현 유형의 문제를 가장 선호한다.

코딩 테스트 문제에서 출제되는 알고리즘 이론이 쉽다고 해서 문제를 쉽게 풀 수 있다는 의미는 아니다.
그리디 유형의 알고리즘은 현재 상황에서 가장 좋은 것만을 선택하면 되는 알고리즘이라서 알고리즘 유형의 정의만 들었을 때는 굉장히 쉬워 보이지만 난이도가 낮은 거스름돈 무제 같은 그리디 문제는 쉽게 해법을 찾아낼 수 있다.
하지만 그리디 유형의 문제는 출제자가 마음만 먹는다면 매우 어려운 난이도로 출제할 수 있다. 단지 기업의 코딩 테스트는 테스트의 목저인 '직원 선발'에 맞는 수준으로 난이도를 조정했을 뿐이다. 알고리즘 대회라면 얼마든지 매우 높은 난이도의 그리디 유형 문제도 출제할 수 있다.
일반적으로 알고리즘 코딩 테스트는 2~ 5시간가량의 제한된 시험시간에 8개 이하의 문제를 푸는 형태로 출제된다.
시간이 촉박하기 때문에 평상시 프로그램을 개발하거나 학교 과제용 문제풀이에 비하면 심리적으로 부담이 되는 편이다. 따라서 이런 시간 제한이 있는 코딩 테스트는 연습해두지 않으면 평소의 문제 해결 기량에 비하여 좋은 성과가 나오지 않을 수 있다.

자격증 시험이나 어학 능력 시험만을 응시해본 학생들은 단순히 '몇 시간 동안 8문제 이하의 문제를 푼다면 시간이 충분하겠다'라고 생가할 수있다. 실제 접해보면 알겠지만 알고리즘 분야는 다른 분야에 비해서 문제 해석 및 답안 작성에 투자해야하는 시간이 긴편이다.
다른 시험보다 문제를 풀기 위해 투자해야하는 시간이 길다보니, 대부분 코딩 테스트에 참여하는 취업 준비생은 문제풀이 시간이 부족하고 촉박하다고 느낀다. 
알고리즘 코딩테스트에서는 몇 개의 문제를 해결해야 합겨할 수 있을까?
출제자의 의도에 따라서 다르겠지만, 대부분의 알고리즘 대회 및 코딩 테스트에서는 상위 5% 미만의 사람만 문제를 전부 풀 수 있으며 전체 문제중 절반가량을 정확히 해결할 수 있다면 합격할 수 있다.
문제 난이도와 합격 비율을 확인해보는 차원에서 삼전, 라인, 카카오, 세 기업에서 이루어진 채용 목적의 코딩 테스트에 한 번이라도 참가해본 적이 있는 2년차 이하의 IT직군 신입대상은 평균 69%문제를 풀었으며 불합겨자는 38% 문제밖에 풀지 못했다고 한다.
코딩 테스트는 일종의 주관식 시험으로 많은 양의 문제를 맞혀야하는 어학 능력 시험과는 사뭇 다른 느낌을 받는다.적정 수준의 문제 해결 역량을 갖추면 기업 코딩 테스트를 준비하기가 좀 더 수월하다고 함
국제 알고리즘 대회를 기준으로 설명하면 코드포스 블루 이상, ACM-ICPC 서울 지역대회 본선에 안정적으로 진출 할 수 있는 수준이라면 모든 기업의 코딩 테스트에서 합격 안정권에 들 수 있다고 판단한다.
알고리즘 대회와 기업 코딩 테스트는 사뭇 다르므로 기업 코딩 테스트에서는 대회 입상을 목표로 하는 사람들이 학습해야하는 고난도 알고리즘으 ㄹ주로 다루지는 않음

대회 입상이 목표가 아니라면 고급 알고리즘까지 공부할 필요는 없음
취업에 필요한 코딩 테스트를 준비한다면 코딩 테스트에 출제되었던 문제 유형을 확인하고 코딩 테스트에 자주 출제되는 유형 위주로 학습을 진행하는 것이 유리함
기초 알고리즘을 시작으로 꼼꼼히 공부하는 것만으로도 충분히 코딩 테스트 합격을 노려보자
채긍 우선순위가 높은 순서로 알고리즘 이론과 문제들을 차례로 제시함
연도별 유형 분석에 나온 알고리즘을 당장 깊게 공부할 필요도 암기할 필요도 없음
마음 편히 읽은 뒤 주요 알고리즘 이론과 실전 문제를 다루는 2부를 공부하는 것도 추천함

알고리즘 문제가 아닌 개발 관련 문제에서는 C++나 자바에 비해 파이썬이 단연 유리함
간단한 형태의 API 시스템을 설계하는 과정에 있어서는 파이썬이 상대적으로 유리하다.
C++와 자바에 비해서 파이썬을 이용하여 코딩 테스트를 준비했던 학생의 합격률이 상대적으로 높은 것을 확인 할 수 있다.


## 기술 면접의 대표 유형
### 알고리즘 문제 풀이와 질의응답 형식
기술 면접의 가장 대표적인 방법이다. 코딩 테스트를 치른 내용을 토대로 면접을 진행하며 알고리즘 역량을 제대로 갖추었는지 확인
책의 다양한 코딩 테스트 문제를 풀고 관련 알고리즘 원리를 완전히 자기 것으로 만들기를 권함
그래야만 면접에서 알고리즘 질문에 제대로 답할 수 있음
알고리즘 문제를 푸는 것도 중요하지만, 이후 기술 면접에서 잘 대답하려면 문제 접근 방식과 풀이 방식을 설명할 수 있어야함 그러려면 자료구조와 알고리즘에 대한 이해가 바탕이 되어야 한다.
책을 읽으며 어떤 상황에 어떤 알고리즘을 사용하는지 적어둔 부분을 잘 익혀두기

기술 면접에서 정렬 알고리즘의 시간 복잡도를 물어봤다면, '선택정렬, 삽입정렬 등은 최악의 경우 O(N^2)의 시간이 소요되지만 병합 정렬 등은 최악의 경우에도 시간 복잡도 O(NlogN)을 보장하는 형태로 정렬 기능이 제공되고 있는 등' 경우에 따라서는 계수 정렬과 같은 O(N+K)를 보장하는 정렬 알고리즘을 사용할 수 있다든지 등을 설명할 수 있으면 좋음. 즉 단순히 어떤 정렬 라이브러리의 시간복잡도가 높다, 낮다를 판단하는 것만으로는 부족하고, 실제로 서로 다른 알고리즘을 비교하여 '특정한 상황'에 무엇이 더 좋을지를 설명할 수 있어야함

### 포트폴리오 질의 응답
투입될 개발 프로젝트에 필요한 지식을 갖추고 있는지 물어볼 때 주로 이용되는 유형
작은 규모의 기업에서는 장기간에 걸쳐 신입을 교육시키는 프로세스가 없을 수도 있다. 특히 진행중인 개발 프로젝트에 개발자를 바로 투입해야한다면 지원자가 수행했던 프로젝트 경험이 본 회사에 적합한지를 물어보곤한다.
다시 말해 당장 개발 인력을 투입해야하는 상황이라면 특정 라이브러리나 프레임워크의 경험을 평가 기준으로 삼는다. 신입 직원의 잠재력도 중요하지만 경험을 더 중요하게 볼 수도 있다는 것임
항상 그렇지는 않지만, 특정 기술에 능숙하다면 해당 업무에서 필요로 하는 수준의 알고리즘 역량을 갖췄을 가능성이 높음 개발 경험에 가중치를 부여하는 회사는 포트폴리오를 상당히 중요하게 본다. 이를 대비해 공부하면서 만든 토이 프로젝트를 정리하여 포트폴리오로 만들어 두면 좋음
웹 개발 회사의 취업을 고려한다면 스프링이나 Node.js를 이용하여 게시판 기능을 구현하는 프로젝트를 만들어보기
게임 개발 회사의 취업을 고려한다면 유니티 엔진을 이용해 프로젝트를 만들어보자
포트폴리오를 완성했다면 다른 사람이 보기 편하게 문서화하는 것도 잊지 말자.
프로젝트당 1~2장 정도의 분량으로 개발 과정 등을 문서로 정리해두고 팀 프로젝트라면 본인이 맡은 역할과 이슈를 해결하면서 배운 내용등을 문서에 담도록 하자. 또한 전체 소스코드를 깃허브에 올리고 이력서에 깃허브 주소를 첨부하는 것이 좋다. 이력서를 본 면접관은 프로젝트와 관련된 내용으로 심층 질문을 할 가능성이 높음
더불어 프로젝트 후 배포 경험까지 있으면 좋은데, 이 과정에서 AWS나 Google Cloud Platform과 같은 클라우드 서비스를 이용해본 경험이 있으면 이 또한 이력서에 기술하자

### 컴퓨터 공학 지식 질의응답 형식
기술 면접 때 컴퓨터공학에 대한 전반적인 지식을 질문하기도 함.
운영체제나 컴퓨터 아키텍쳐, 개발 방법론 등에 대한 이해가 있어야 개발할 수 있는 분야도 있기 때문
서버 개발에서는 멀티 스레딩, 메모리 관리 등을 알아야함. 따라서 지원한 직군이 서버 계열이라면 당연히 이러한 지식에 관해서 물어볼 수 있으므로 미리 준비해야 한다. 어느 분야든 네트워크에 대한 지식이 필요하다.
웹 개발 직군에 지원한다면 당연히 GET, POST 방식의 차이나 TCP, UDP, HTTP, HTTPS의 개념과 원리를 알아야 한다. 데이터베이스 관련 직군이라면 데이터베이스의 정규화 인덱스, NoSQL 등 다양한 데이터베이스 관련 내용에 관해서 물어볼 수 있다. 이처럼 알고리즘을 제외한 컴퓨터 공학 지식은 주로 직무와 관련된 내용을 물어보므로 관련 분야의 지식을 중점으로 알아두자. 깃허브에 국내 기술 면접에 대한 전반적인 내용을 정리한 '국내 기술 면접 가이드라인'저장소를 기술 면접 전 읽어보자 분야별로 알아두어야 하는 내용이 정리되어 있음
[면접 가이드라인](https://github.com/JaeYeopHan/Interview_Question_for_Beginner)


## 기술 면접 준비
누차 이야기하지만, 알고리즘 문제를 잘 풀었다고 기술 면접을 항상 쉽게 통과할 수 있는 것은 아니다.
기업에서 원하는 직원은 문제를 풀어 '정답판정'을 받는 지원자가 아니라, 자신이 어떤 방법으로 문제에 접근하여 어떠한 알고리즘을 사용했는지를 논리 정연하게 설명할 수 있는 지원자를 원함
채용 프로세스란 회사에세 같이 일할 사람을 뽑는 과정이므로 논리적으로 말로 정리하는 능력도 매우 중요함
이러한 능력은 하루아침에 생기는 게 아니므로 평소에 기술 블로그나 깃허브 저장소를 운영하며 능력을 키워갈 수 있다. 또한 글로도 논리적인 풀이 능력을 확인할 수 있으므로 채용시 장점이 될 수도 있다.
이번에는 기술 면접을 준비하기위한 기본 팁에 대해 소개함
### 깃허브 사용하기
깃허브는 가장 유명한 오픈소스 프로젝트 공유 웹사이트이다. 누구나 자신이 개발하고 있는 프로젝트를 오픈소스로 공유할 수 있음 많은 개발자가 자발적으로 깃허브에 업로드하여 관리하며 오픈소스 생태계에 기여하고 있다.

깃허브 사용법은 인터넷이나 책으로 쉽게 익힐 수 있음 깃허브에 프로젝트 파일을 올리는 일은 굉장히 쉬우므로 겁먹을 필요 없음
처음은 간단한 웹 애플리케이션, 웹사이트 소스코드를 올리는 정도로 충분하지만
백준 온라인 저지나 코드포스에서 풀었던 문제의 정답 소스코드를 저이리해서 올리는 것도 좋음
깃헙은 소스코드를 업로드한 시점을 기록해주는데 이가 로그와 같은 형태로 남음

### 기술 면접의 어려움
기술 면접을 볼  때 보통 개발자가 면접관으로 1명 이상 참석한다. 개발자마다 중요하게 생각하는 부분이 다를 수 있어 기술 면접을 완벽하게 대비하는 일은 불가능함
어떤 면접관은 수학과 알고리즘 원리를 중요하게 생각해서 업무에 필요한 알고리즘 원리에 초점을 맞추어 질문할 수 있고 어떤 면접관은 프레임워크나 라이브러리를 다룬 경험을 중요하게 생각해서 관련 경험을 주로 물어볼 것

### 인성 면접 질문 리스트
대표적인 인성 면접 질문
### Q. 개발하면서 가장 행복했던 일은 무엇인가요?
> 개발자로서 열정을 느낀 경험을 물어보는 질문. 개발하면서 행복감을 느꼇던 순간이나, 보람을 느꼇던 경험을 이야기하면 좋다. 채용자는 같이 일할 만한 사람인지를 확인하고자 이러한 질문을 한다. 따라서 자신이 개발하면서 얼마나 행복함을 느끼는지, 어떨 때 기쁜지 등으 ㄹ서렴ㅇ하면서 개발을 좋아한다는 점을 알리는게 중요함

#### Q. 자신이 가장 열정적으로 참여했던 프로젝트가 있다면 이야기해주세요
이 질문에는 자신이 열정적으로 참여했던 프로젝트를 소개하고, 누구와 함께 했는지, 자신이 맡은 역할이 무엇이었는지 답하면 된다. 특히 프로젝트에서 자신이 기여한 파트를 구체적으로 언급하고 그 과정에서 겪었던 어려운 점을 어떻게 해결하여 실력 향상을 이룰 수 있었는지에 대해서 설명할 수 있을 정도로 준비를 하자

#### Q. 회사에 대해 궁금한 점이 있으면 말해주세요
> 면접은 단순히 회사에 채용되는 과정이 아니라 여러분 또한 회사를 선택하는 입장이라는 점을 기억하자
> 따라서 회사에 대하여 궁금한 점이 있다면 질문할 수 있도록 사전에 회사에 대해 알아보고 면접에 임하자.
> 1차원적으로 궁금한것을 직접 물어보는 것보다는 자신의 개발자로서의 성향 중에 '긍정적인 성향'을 드러낼 만한 질문을 하는 것이 좋다. ex) 회사에서 기계식 키보드를 이용해도 좋은지 혹은 평소에 컴퓨터 장비에 관심이 많은 것처럼 느껴질 수 있다. 
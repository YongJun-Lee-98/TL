러스트의 모듈은 트리 구조로 표현된다. 이런 모듈의 모음을 크레이트 라고 한다.
크레이트를 관리하는 것이 패키지다.
이 섹션에서는 러스트의 패키지, 크레이트, 모듈의 동작에 대해 알아본다.

## 왜 기능별로 분리해야 하는가?
먼저 모듈과 크레이트가 필요한 이유를 생각해보자
기본적으로 모듈이나 크레이트라는 것은 프로그램을 나누는 단위다.

프로그램을 나누는 이유는 무엇일까?
대규모 시스템을 구축한다면 프로그램을 기능별로 분리하는 것이 유리하다.
프로그램을 기능별로 나누면 프로그램의 구조를 알기 쉽게 되며 해당 기능 개발에 집중하기 쉬워진다.
그리고 업무 분담도 가능하며 문제가 발생했을 때 원인을 찾기도 쉬워진다.

즉 프로그램을 분할한다는 것은 전체적인 효율을 높인다는 것이다.

### 패키지, 크레이트 모듈
러스트의 기본 단위는 모듈이다. 모듈을 모은 것이 크레이트고 크레이트를 관리하는 패키지가 있다.
모듈은 스코프(범위) 단위다. 모듈의 관계는 트리 구조로 표현할 수 있다.
'크레이트(crate)'는 트리 구조로 표현되는 모듈군 전체를 말한다. 모듈의 트리 가장 위에는 크레이트가 있다.
'패키지(package)'는 복수의 크레이트를 관리한다. 패키지 관리 시스템인 Cargo와 밀접하게 엮인 단위로 크레이트를 빌드하거나 테스트 한다.

### 트리 구조인 러스트 모듈
트리 구조는 파일 시스템 등에서 자주 접할 수 잇는 형태로 나무가 가지를 뻗어나가는 형태로 구조가 만들어진다.
XML이나 JSON으로도 트리 구조 데이터를 다룰 수 있다.
러스트의 모듈은 하나의 모듈 아래에 1개 이상의 서브 모듈이 잇으며, 서브 모듈에도 그 하위의 서브 모듈을 가질 수 있다.

### 모듈은 1개의 파일에 여러 개 정의할 수 있다.
파이썬은 1개의 파일은 1개의 모듈로 구성된다. 하지만 러스트는 1개의 파일 안에 여러 개의 모듈을 정의할 수 있다.
선형 합동법과 XorShift라는 2개의 알고리즘을 이용해 32비트 의사난수를 생성하는 모듈을 만들고 그것을 이용하는 프로그램이다.
```rust
// random 모듈 선언
mod random {
	// linear 모듈 선언
	pub mod linear {
		use std::num::Wrapping;
		// 선형 합동법으로 난수 생성
		pub fn rand(seed: &mut u32) -> u32 {
			let (a, c) = (134775813u32, 12345u32);
			*seed = (Wrapping(*seed) * Wrapping(a) +
					Wrapping(c)).0;
			*seed
		}
	}
	
	// xorshift 모듈 선언
	pub mod xorshift {
		//XorShift로 난수 생성
		pub fn rand(seed: &mut u32) -> u32 {
			let mut y = *seed;
			y ^= y << 13;
			y ^= y >> 17;
			y ^= y << 5;
			*seed =y;
		}
	}
}

// 모듈 이용 선언
use random::{linear, xorshift}
fn main() {
	// 각 알고리즘으로 10개의 난수를 생성
	let mut seed1 = 12345u32;
	let mut seed2 = 12345u32;
	for i in 0..10 {
		let r1 = linear::rand(&mut seed1) % 6 + 1;
		let r2 = xorshift::rand(&mut seed2) % 6 + 1;
		println!("L : {:2} 번째 = {}, {}", i+1, r1, r2)
	}
}
```

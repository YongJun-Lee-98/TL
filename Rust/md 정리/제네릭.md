제네릭은 다른 타입이라도 동일하게 조작할 수 있게 해주는 기능이다.
이미 Vec과 HashMap을 통해 기본적인 사용방법은 알고 있음
제네릭을 이용한 구조체와 ㅂ녀수의 정의 방법을 소개하기
## 제네릭 복습하기
generic은 추상적인 타입을 지정해 다양한 데이터 타입 조작을 가능하게 하는 프로그래밍 기법이다. 이미 Vec와 HsahMap을 이용해 프로그램을 만들어 봤으므로 제네릭에 대해 어느정도 이해는 하고 있을 것임
Vec으 ㄹ이용한 간단한 프로그램을 만들어 보기
i32 타입과 char 타입 벡터를 만들고 그 조작 방법을 비교하는 것

```rust
fn main() {
	// i32 타입을 Vec을 사용
	let mut v1: Vec<i32> = Vec::<i32>::new();
	v1.push(10);
	v1.push(20);
	v1.push(30);
	v1.pop(); // 마지막 요소 꺼내기
	// v1 변수의 요소를 하나씩 출력
	for i in v1.iter() {
		println!("{}", i);
	}
	
	// char 타입 Vec을 사용
	let mut v2: Vec<char> = Vec::<char>::new();
	v2.push('a'); // 요소를 v2에 추가
	v2.push('b');
	v2.push('c');
	v2.pop(); // 마지막 요소 꺼내기
	// v2 변수의 요소르 하나씩 출력
	for i in v2.iter() {
		println!("{}", i);
	}
}
```

## 제네릭 함수 정의
제네릭을 이용하면 함수나 메서드의 사용 방법을 통일할 수 있다는 장점 외에도 코드 중복을 줄일 수 있다는 장점도 있다.
i32 타입 값을 더하기만 하는 add_i32 함수와 f32 타입 값을 더하기만 하는 add_f32 함수를 만들어야 한다면 다음과 같이 만들 수 있다.

```rust
fn add_i32(a: i32, b: i32) -> i32 {
	a + b
}

fn add_f32(a: f32, b: f32) -> f32 {
	a + b
}

fn main() {
	println!("{}", add_i32(10, 25));
	println!("{}", add_f32(10.0, 25.0))
}
```

add_i32 함수와 add_f32 함수를 보면 타입 선언이 다를 뿐이지 구조는 같다.
러스트는 타입 체크를 엄격하게 하므로 타입이 다르면 컴파일이 되지 않는다. 하지만 타입이 다르기 때문에 다른 함수를 추가로 만들어야 한다는 건 꽤 불편한 일이다. 
이렇게 비슷한 함수가 여러 개 있다면 실수가 발생할 가능성도 높음

이럴 때 이용하는 것이 제네릭이다.
#### 제네릭 예시

```rust
// 제네릭을 이용해 add 정의
fn add <T: std::ops::Add<Output=T>> (a:T, b:T) -> T {
	a + b
}

// 함수 사용하기
fn main() {
	println!("{}", add(10, 25));
	println!("{}", add(10.0, 25.0));
	println!("{}", add::<i32>(10, 25));
}
```

#### 제네릭 함수 정의
> fn 함수명 \<T: 트레잇>(인수1: T, 인수2: T, ...) -> 반환값 {
> ...
> }

제네릭 함수에서는 함수명 뒤에 따라오는 <T: 트레잇> 부분이 중요하다. 제네릭을 사용할 때 이 T 타입부분이 임의의 타입으로 변경된다.
서식을 확인하면서 다시 한번 제네릭인 add 함수를 살펴보자. 서식과 실제 코드를 비교하며 어떻게 구현됐는지 확인하기
> fn add <T: std::ops::Add<Output=T>> (a: T, b: T) -> T {
> 	a + b
> }

러스트는 특성상 컴파일러에서 거의 모든 문제를 처리한다.
제네릭도 예외는 아니며 여기서는 인수와 반환 값 타입 T가임의의 타입으로 변경 될 때 프로그램이 올바르게 컴파일 되는지 확인해야 한다.

T 타입인 'std::ops::Add<Ouput=T>' 는 덧셈과 관련된 트레잇이다. std::ops는 오버로드(overload) 가능한 연산자 트레잇을 정의한 모듈이고, Add 트레잇이 덧셈 트레잇이다.

즉 제네릭에 지정 가능한 타입으로 std::ops::Add 트레잇을 지정하면 그 제네릭은 '덧셈을 할 수 있는 타입'을 지정할 수 있다는 의미이다.
정수 타입 i32와 부동 소수점 타입 f32는 당연히 덧셈가능한 타입이고
char은 덧셈이 불가능하므로 에러가 발생한다.

## 트레잇 제한하기
제네릭 타입에 대해 트레잇을 지정하는 것을 '트레잇 바운드(trait bound- 트레잇 경계)'라고 한다. 어떤 타입에도 지정할 수 있어야 하는 제네릭 타입에 트레잇을 지정한다는 것은 '지정한 트레잇을 구현해야 한다'는 제약을 것이다.

## 인수 값을 2배로 하는 제네릭 함수 정의
제네릭 함수를 만드는 연습을 위해 인수로 지정한 값을 2배로 만드는 함수를 만들어 보자
```rust
// 인수 값을 2배로 만드는 제네릭
fn x2 <T: std::ops::Add<Output=T> + Copy> (n: T) -> T {
	n + n
}
fn main() {
	println!("{}", x2(3));
	println!("{}", x2(3.0f64));
	println!("{}", x2::<u64>(3));
}
```
이 섹션에서는 앞 섹션에서 만든 단방향 연결 리스트를 개선해본다. 개선을 위해 참조 카운터 방식인 Rc\<T>와 실행시 빌림 규칙을 강제하는 RefCell\<T>도 함께 알아보기
## Box\<T>를 이용한 단방향 연결 리스트의 단점
앞에서 만든 단방향 연겨 ㄹ리스트에서 Node의 가장 앞에 값을 추가하는 unshift 메서드와 가장 뒤에 값을 추가하는 push 메서드를 구현했다. 여기서 unshift 메서드는 List의 head 필드에 새로운 Node를 넣기만 하면 되므로 성능이 좋다. 반면 push 메서드는 매번 가장 끝의 값을 찾아서 새로운 Node를 추가하는 형태이므로 데이터가 커질수록 효율이 떨어진다.

여기서는 리스트의 끝에도 쉽게 데이터를 추가할 수 있도록 List 필드에 head 외에 foot필드를 추가해 리스트의 처음과 끝을 바로 찾을 수 있게 구현해본다.
## Rc\<T> 타입으로 참조 카운팅 방식 메모리 관리 기능
러스트의 소유권 시스템은 1개의 변수에는 1개의 소유자만이 존재한다. 이는 Box\<T> 타입에서도 마찬가지다. 힙 메모리에 값을 저장했더라도 Box\<T>의 소유권은 1개뿐이다. 따라서 리스트의 시작 부분과 끝 부분의 요소를 저장하기 위해 Box\<T>를 쓰려고 하면 시작 부분 또는 끝 부분 중 하나만 선택해 저장해야 한다. 즉 문제가 해결되지 않는다.

이런 문제를 해결할 수 있는 것이 'Rc\<T>' 타입이다. 이 타입은 Box\<T>와 마찬가지로 힙 영역에 값 T를 저장하지만 참조 카운터 방식으로 메모리를 관리하므로 1개의 객체에 복수의 소유자를 지정할 수 있다.
즉, 값을 공유할 수 있다. Rc는 참조 카운팅(Reference Counting)의 약자다.

참조 카운팅은 C언어의 그것과 같은 방식이다. Rc\<T>의 소유권을 가진 변수가 만들어지면 참조 카운터를 1증가시키며 그 변수가 스코프 밖으로 나가서 파기되면 참조 카운터를 1 감소시킨다. 그리고 참조 카운터가 0이 되면 Rc\<T> 객체가 파기된다. 러스트의 기본 메모리 관리 메커니즘과 비교하면 관리 비용이늘어나지만 소유권을 여러 변수가 가져갈 수 있어 편리성이 높아진다.

2개의 소스를 통해 Rc\<T> 타입의 동작을 확인해보자.
Box\<T> 타입 데이터를 여러 개의 변수에 할당할 수 있는지 확인한다.
```rust
fn main() {
	// 힙 영역에 i32 타입 값 1000을 저장 -1
	let a_box = Box::new(1000);
	{
		let b_box = a_box; // 소유권 이동 -2
		println!("{}", b_box);
	}
	println!("{}", a_box); // 소유권 이동으로 이용 불가 -3
}
```

1 부분에서 i32 타입 값 1000을 지정해 힙 메모리 영역에 저장한다. 그리고 이 값의 포인터인 Box\<i32>를 변수 a_box에 대입한다. 
2 부분에서는 b_box에 a_box를 대입한다. 앞에서 배운 대로 값의 대입 또는 함수를 호출하면 소유권 시스템으로 인해 소유권이 이동한다.
즉 이 시점에 a_box의 소유권이 변경되므로 a_box는 더이상 사용할 수 없다. 따라서
3에서 a_box를 사용하면 소유권 관련 에러가 발생한다.
borrow of moved value: a_box

참조 카운팅 Rc\<T>을 이용해 동일한 내용을 구현해본다.
```rust
use std::rc::Rc;
fn main() {
	// 힙 영역에 i32 타입 값 저장 -1
	let a_rc = Rc::new(1000);
	{
		// i32 타입을 참조하는 b_rc도 생성 -2
		let b_rc = Rc::clone(&a_rc);
		println!("{}", b_rc);
		// a_rc의 참조 카운트 확인 -3
		println!("참조 카운트 = {}", Rc::strong_count(&a_rc));
	} // a_rc의 참조 카운트가 1감소
	println!("{}", a_rc); // Rc 타입이므로 이용 가능 -4
	println!("참조 카운트 = {}", Rc::strong_count(&a_rc));
}
```
1 Rc::new를 이용해 힙 영역에 i32 타입 값 1000을 저장하고 해당 포인터를 변수 a_rc에 대입한다.
2 dptjsms Rc::clone을 이용해 변수 a_rc의 참조자를 복제해 변수 b_rc에 대입한다. 이렇게 해서 변수 a_rc와 b_rc 모두 이용 가능한 상태가 된다. 그리고 이 시점에 참조 카운트는 1이 증가해 2가 된다.
3에서 참조 카운트를 출력하면 증가된 값 2가 출력된다.

그리고 블록 {}를 벗어나면 라이프타임 규칙에 의해 해당 변수가 소멸되므로 참조 카운트는 1이 된다. 하지만 소멸되는 것은 b_rc 뿐이고 a_rc는 아직 수명이 끝나지 않았기 때문에
4에서 a_rc 값을 출력할 수 있다.

Rc::strong_count 함수를 이용하면 참조 카운트 값을 확인할 수 있다. Rc::clone으로 참조 카운트가 증가하거나 변수의 유효범위를 벗어나 변수가 파기돼 참조 카운트가 감소할 때 Rc::strong_count 메서드로 참조 카운트 값을 확인할 수 있다.

### Rc\<T>는 불변
앞에서 확인한 것처럼 Rc\<T>를 이용하면 하나의 값에 여러 소유자를 지정할 수 있다. 하지만 문제가 있다.
```rust
use std::rc::Rc;
fn main() {
	// 힙 영역에 i32 타입 값 1000을 저장
	let mut a_rc = Rc::new(1000);
	// a_rc의 참조를 복제
	let mut b_rc = Rc::clone(&a_rc);
	// b_rc 값 변경 시도
	*b_rc += 100; // 에러가 발생하는 부분
	println!("{}", b_rc);
}
```
Rc\<T> 는 여러 소유자를 지정할 수 있지만 값을 변경할 수 없다. 한번 Rc\<T>로 객체를 설정하면 그 순간 값이 고정되므로 값을 갱신해야 하는 경우에는 사용이 불가능하다.

## RefCell\<T> 타입 사용
하나의 변수에 여러 소유자를 지정해야 하고 값을 변경해야 하는 경우 사용하는 것이 바로 RefCell\<T>다.
이것은 컴파일을 할 때가 아니라 컴파일 후 프로그램을 실행할 때 빌림 규칙을 강제하므로 값 변경이 가능하다.
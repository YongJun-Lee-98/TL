## 'null 안전' 언어 러스트
C언어와 자바 같은 대부분의 언어에는 null이라는 개념이 있다.
파이썬에도 null에 해당하는 None이 있다.
null이란 아무것도 없다는 것을 의미하지만 프로그래밍에서는 값이 존재하지 않는다는 것을 나타낸다.
C언어에서는 문자열의 끝을 표시하기 위해서도 null을 이용한다.
이 null로 인해 많은 버그들이 발생함
1965년 null 포인터 개념을 만든 안토니 호어는 2009년의 강연에서 null 포인터를 만든 것은 10억 달러짜리 실수라고 했음
null로 인해 수맣은 에러와 취약점, 치명적인 시스템 러가 발생했다는 것이 그 이유였음
null의 가장 큰 문제는 어느 변수에 null 값이 할당됐는지 정적으로 판단할 수 없다는 것임
컴파일 할 때 null과 관련된 문제가 있는지 없는지 알 수 없으며, 그것은 결국 버그로 이어질 수 있다.

### 파이썬 null 안전 확인
실제로 null로 인해 문제가 발생하는 경우를 살펴보기
간단하게 숫자를 하나씩 증가시키는 카운터 프로그램을 통해 확인해보기
먼저 숫자를 하나씩 올리기 위해 이용할 Counter클래서ㅡ를 정의한다.
Cpunter 객체에 값을 1 증가시키는 inc라는 메서드를 만든다.
그리고 Counter 객체를 대입한 변수 a에 대해 inc 메서드를 호출한다
이때 다음과 같이 코드를 작성하면 문제가 발생한다.
Counter 객체를 인수로하는 count 함수를 호출한다.

```python
# Counter 클래스 정의
class Counter:
	value = 0
	# 값을 증가시키는 메서드
	def inc(self):
		self.value += 1
		print("value=", self.value)

# Counter 클래스를 인수로 하는 함수
def count(counter):
	counter.inc()

# 올바르게 이용되는 경우
a = Counter()
count(a)
count(a)

# 문제가 발생하는 경우
a = None
count(a)
```

간단하게 동작을 확인해보면 계산을 위한 Counter클래스와 값을 1씩 증가시키는 inc메서드를 정의함
Counter클래스 객체를 인수로 하는 count 함수를 정의했음
올바른 사용 방법으로 클래스와 메서드를 이용한다. Counter 객체를 생성하고 생성한 객체를 인수로 count 함수를 호출한다. 이 부분은 문제 없이 Counter 객체의 값이 표시된다.
변수 a에 None 를 대입하고 해당 변수를 인수로 해 count 함수를 호출한다. 결과적으로 "AttributeError: 'NoneType' object has no attribute 'inc'(NoneType 객체에는 inc라는 속성이 없음)"라는 에러를 발생시킨다.
이 파이썬 프로그램의 문제는 실행하지 않으면 에러가 발생할지 알 수 없다는 것이다. 문법적으로는 문제가 없기 때문임

명령줄에서 python -m py_compile <확인하고 싶은 파이썬 소스 코드 파일> 형태로 입력하면 해당 파이썬 소스 코드에 문제가 있는지 확인할 수 이싿.
python -m py_compile counter_err.py를 입력해도 문법적인 문제가 없으므로 에러는 표시되지 않는다.
이것이 바로 null이 가진 문제점이다.

### 러스트에서 값이 없다는 것을 표현
러스트는 애초에 null 포인터 참조를 할 수 없다.
그래서 그와 관련된 문제는 발생하지 않는다. 예외적으로 unsafe 블록을 만들어 null 포인터를 참조할 수 있지만
어디까지나 예외적인 것임 언어 사양에서 문제가 발생하기 쉬운 기능을 제거하는 것은 현명한 방법이다. 하지만 기능을 제거하더라도 변수가 비어 있거나 이를 참조할 때 값이 없는 경우가 사라지는 것은 아니다.

러스트에서는 일반적인 언어의 null이나 None을 표현하기 위해 Option 또는 Result 타입 같은 열거형을 사용한다.

열거형인 Option 타입에는 값이 있거나(Some) 없는(None) 것을 표현할 수 있다.
앞에서 다룬 파이썬 예제를 러스트로 구현하면 다음과 같음
```rust
// Counter 구조체 정의
struct Counter {
	value: i64,
}
impl Counter {
	fn new() -> Self {
		Counter { value: 0 }
	}
	fn inc(&mut self) {
		self.value += 1;
		println!("value={}", self.value);
	}
}

// Counter 구조체를 인수로 하는 함수
fn count(counter: Option<&mut Counter>) {
	match counter {
		None => return,
		Some(c) => c.inc(),
	};
}

fn main() {
	// Counter 구조체를 인수로 count 함수를 호출
	let mut a = Counter::new();
	count(Some(&mut a));
	count(Some(&mut a));
	// None 객체를 인수로 호출
	let a = None;
	count(a);
}
```
Counter 구조체와 inc 메서드를 정의했음
Counter 구조체를 인수로 하는 함수 count를 정의했음
Counter 객체를 인수로 삼아 count 함수를 호출한다.
None을 인수로 지정해 count 함수를 호출함
러스트는 기본적으로 값이 존재하지 않을 가능성이 있는 경우 Option\<T> 형태로 표현한다.
Option 타입에서 실제값을 얻기 위해서는 match 문을 이용해 None 인지 Some 인지 확인한 뒤 처리한다.
그러므로 러스트에서 값이 없어서 프로그램이 강제로 종료되는 버그는 발생하지 않는다. 물론 Option 타입에서 그냥 값을 빼는 unwrap 메서드를 이용한다면 때에 따라서는 패닉 에러가 발생해 프로그램이 강제로 종료되지만, 이는 프로그래머가 의도적으로 만든 상태라고 할 수 있다.

## 열거형 정의하기
Option 타입은 러스트의 기본 열거형이지만 직접 열거형 데이터를 정의할 수도 있다. 열거형 데이터는 enum을 이용해 만든다.
> \[서식] 열거형 정의
> enum 열거형 이름 {
> 	값 1, 값 2, 값 3, ...
> }

열거형 데이터를 이용하기 위해서 열거형 객체를 만들어야 한다.
객체 생성은 다음과 같이 '타입 이름::값' 형태로 기술해 만들 수 있다.

열거형 데이터를 이용하기 위해서는 열거형 객체를 만들어야 한다.
> \[서식] 열거형 이용(객체 생성)
> let 변수 1 = 열거형::값 1,
> let 변수 2 = 열거형::값 2,

열거형의 값으로는 임의의 데이터 타입을 지정할 수 있다.
> \[서식] 타입을 가진 열거형 데이터를 선언하는 방법
> enum 열거형 이름 {
> 	값 1 (데이터 타입),
> 	값 2 (데이터 타입, 데이터 타입, 데이터 타입),
> 	값 3 { 필드 이름 : 데이터 타입, 필드 이름 : 데이터 타입, ...}
> }

### 동전 계산하기
 열거형 이해를 위해 동전 계산 프로그램을 만들어 보기
```rust
// 화폐 종류를 나타내기 위한 열거형
enum Currency {
	Currency100(isize),
	Currency500(isize),
	Currency1000(isize),
	Currency5000(isize),
	Currency10000(isize),
	Currency50000(isize),
}
impl Currency {
	// 화폐 종류로 실제 금액 계산
	fn calc_price(&self) -> isize {
		match *self {
			Currency::Currency100(v) => v * 100,
			Currency::Currency500(v) => v * 500,
			Currency::Currency1000(v) => v * 1000,
			Currency::Currency5000(v) => v * 5000,
			Currency::Currency10000(v) => v * 10000,
			Currency::Currency50000(v) => v * 50000,
		}
	}
}

fn main() {
	// 지갑 안에 있는 동전 종류와 개수 지정
	let wallet: Vec<Currency> = vec![
		Currency::Currency100(3),
		Currency::Currency500(2),
		Currency::Currency1000(6),
		Currency::Currency5000(1),
		Currency::Currency10000(8),
		Currency::Currency50000(3),
	];
	// 전체 금액을 계산해서 출력
	let total = wallet.iter()
		.fold(0, |sum, v| sum + v.calc_price());
	println!("지갑 안의 금액은 {} 원입니다.", total);
}
```


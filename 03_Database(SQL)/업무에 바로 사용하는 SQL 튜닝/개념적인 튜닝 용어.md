"""
오브젝트들을 스캔하는 유형.
디스크 접근 방식 등 쿼리 튜닝과 관련된 용어를 설명함
"""

## 오브젝트 스캔 유형
오브젝트 스캔 유형은 아래와 같이 구분됨
- table scan (테이블 스캔)
- index scan (인덱스 스캔)

테이블 스캔은 인덱스를 거치지 않고 바로 디스크에 위치한 테이블 데이터에 접근하는 유형
인덱스 스캔은 인덱스로 테이블 데이터를 찾아가는 유형

테이블 스캔 유형 - 테이블 풀 스캔 방식
인덱스 스캔 유형 - 범위 스캔, 인데스 풀 스캔, 인덱스 고유 스캔, 인덱스 루스 스캔, 인덱스 병합 스캔 방식

### table scan
#### table full scane
테이블 풀 스캔은 인덱스를 거치지 않고 테이블 바로 직행하여 처음부터 끝까지 데이터를 훑어보는 방식임
WHERE 절의 조건문을 기준으로 활용할 인덱스가 없거나, 전체 데이터 대비 대량의 데이터가 필요할 때 테이블 풀 스캔을 수행할 수 있습니다.
다만 테이블 풀 스캔은 보통 처음부터 끝까지 데이터를 검색하므로 성능 측면에서는 부정적으로 해석됨

테이블 풀스캔은 인덱스 없이 사용하는 유일한 방식임을 기억해야함

### index scan
#### index range scan
인덱스 범위 스캔은 말 그대로 인덱스를 범위 기준으로 스캔한 뒤 스캔 결과를 토대로 테이블의 데이터를 찾아가는 방식임

SQL 문에서 BETWEEN ~ AND 구문이나 <, >, LIKE 구문 등 비교 연산 및 구문에 포함될 경우 인덱스 범위 스캔으로 수행함
좁은 범위를 스캔할 때는 성능적으로 매우 효율적인 방식이지만 넓은 범위를 스캔할 때는 비효율적인 방식이라고 할 수 있음

#### index full scan
인덱스 풀 스캔은 말 그대로 인덱스를 처음부터 끝까지 수행하는 방식임
단, 테이블에 접근하지 않고 인덱스로 구성된 열 정보만 요구하는 SQL 문에서 인데스 풀 스캔이 수행됨
인덱스는 테이블보다 상대적으로 적은 양을 차지하므로 테이블 풀 스캔 방식보다는 인덱스 풀 스캔 방식이 성능상 유리함
인덱스라는 오브젝트의 전 영역을 모두 검색하는 방식인 만큼 검색 범위를 최대한 줄이는 방향으로 SQL 튜닝을 해야함

#### index unique scan
인덱스 고유 스캔은 기본 키나 고유 인덱스로 테이블에 접근하는 방식으로, 인덱스를 사용하는 스캔 방식 중 가장 효율적인 스캔 방법임 WHERE 절에 = 조건으로 작성하며, 해당 조인 열이 기본 키 또는 고유 인덱스의 선두 열로 설정되었을 때 활용함

#### index loose scan
인덱스 루스 스캔은 인데스의 필요한 부분들만 골라 스캔하는 방식
인덱스 범위 스캔처럼 넓은 범위에 전부 접근하지 않고, WHERE 절 조건문 기준으로 필요한 데이터와 필요하지 않은 데이터를 구분한 뒤 불필요한 인덱스 키는 무시함

인덱스 루스 스캔은 보통 GROUP BY 구문이나 MAX(), MIN() 함수가 포함되면 작동함
이미 오름차순으로 정렬된 인덱스에서 최댓값이나 최솟값이 필요한 경우가 이에 해당함

#### index merge scan
인덱스 병합 스캔은 테이블 내에 생성된 인덱스들을 통해서 스캔하는 방식
WHERE 문 조건절의 열들이 서로 다른 인덱스로 존재하면 옵티마이저가 해당하는 인덱스를 가져와서 모두 활용하는 방식을 취함
통합하는 방법으로는 UNION(결합)과 INTESECTION(교차) 방식이 있으며 이들 방식은 모두 실행 계획으로 출력됨

인덱스 병합 스캔은 물리적으로 존재하는 개별 인덱스를 각각 수행하므로 인덱스에 접근하는 시간이 몇 배로 걸림
따라서 별개로 생성된 인덱스들은 보통 하나의 인덱스로 통합하여 SQL 튜닝을 수행하거나
SQL 문 자체를 독립된 하나의 인덱스만 수행하도록 변경이 가능함

## 디스크 접근 방식
원하는 데이터를 찾으려고 데이터가 저장된 storage의 페이지에 접근함
페이지란 데이터를 검색하는 최소 단위로, 페이지 단위로 데이터 읽고 쓰기를 수행할 수 있음
서로 연결된 페이지를 차례대로 읽을 수도 있고,
여기저기 원하는 페이지를 임의로 열어보면서 데이터를 읽을 수도 있음.
전자를 시퀀셜 액세스라 하고 후자를 랜덤 액세스라 함

### sequential access
시퀀셜 액세스는 물리적으로 인접한 페이지를 차례대로 읽는 순차 접근 방식으로, 보통 테이블 풀 스캔에서 활용함
데이터를 찾고자 이동하는 disk header(디스크 헤더)의 움직임을 최소화하여 작업 시가과 리소스 점유 비용을 줄일 수 있음
테이블 풀 스캔일 때는 인접한 페이지를 여러개 읽는 multi-page read 방식으로 수행함

스토리지에 있는 7개 페이지를 차례대로 읽고 있음을 보여줌
읽는 페ㅔ이지 순서는 1234567 순서로 읽음

### random access
랜덤 액세스는 물리적으로 떨어진 페이지들에 임의로 접근하는 임의 접근 방식으로 페이지가 위치한 물리적인 위치를 고려하지 않고 접근함.
페이지에 접근하는 디스크 헤더가 정해진 순서 없이 이동하는 만큼 디스크의 물리적인 움직임이 필요하고 다중 페이지 읽기가 불가능하기 때문에, 데이터의 접근 수행 시간이 오래걸림
따라서 최소한의 페이지에 접근할 수 있도록 접근 범위를 줄이고 효율적인 인덱스를 활용할 수 있도록 튜닝하여야함

### 조건 유형
SQL 문의 WHERE 절 조건문 기준으로 데이터가 저장된 디스크에 접근하게 됨. 이때 필요한 데이터에 액세스하는 조건문으로 데이터를 가져오고, 가져온 데이터에서 다시 한번 출력할 데이터만 추출함
이때 맨 처음 디스크에서 데이터를 검색하는 조건을 액세스 조건이라 하고 디스크에서 가져온 데이터에서 추가로 추출하거나 가공 및 연산하는 조건을 필터 조건이라고 함

#### access condition
액세스 조건은 디스크에 있는 데이터에 어떻게 접근할 것인지를 다루는 SQL 튜닝에서 가장 중요한 핵심 사항임
WHERE절 조건문으로 필요한 데이터만 골라 가져오는 방식은 이전 단락의 오브젝트 스캔 유형에서 이미 설명했듯이 테이블에 직접 접근할지, 인덱스를 어떻게 활용할 것인지에 관한 문제임
SQL 조건문이 복잡하고 다양한 만큼 실제 데이터를 가져오기 위해 활용하는 SQL무느이 조건절에는 한계가 있음
따라서, 옵티마이저는 WHERE절의 특정 조건무을 이용해 소량의 데이터를 가져오고, 인덱스를 통해 시간 낭비를 줄이는 조건절을 선택하여, 스토리지 엔진의 데이터에 접근하고 MySQL 엔진으로 데이터를 가져옴
WHERE 절에 ID = 1 과 CODE = 'A' 조건문이 있지만 ID 열로 생성된 인덱스(Table2_index)를 활용하여 TABLE2 테이블의 일부 데이터에 접근하는 것을 알 수 있음
즉, ID = 1 조건문이 액세스 조건인 것
만약 CODE = 'A' 조건문을 액세스 조건으로 삼아 데이터에 접근한다면 인데스 활용 없이 대량의 데이터에 접근할 것으로 예측할 수 있음

### filter condition
필터 조건은 액세스 조건을 이용해 MySQL 엔진으로 가져온 데이터를 기준으로, 추가로 불필요한 데이터를 제거하거나 가공하는 조건임
액세스 조건으로 가져온 가져온 데이터를 대상으로 필터조건인 CODE = 'A'를 적용해 필터링 작업을 합니다.
만약 필터 조건에 따라 필터링할 데이터가 없다면 매우 훌륭한 SQL문이고, 필터 조건으로 필터링되어 제거된 데이터가 다수 존재한다면 상대적으로 비효율적인 SQL 문일 것임
그 이유는 스토리지 엔진에서 MySQL 엔진으로 데이터를 전달하는 오버헤드가 있으며
필터 조건으로 제거될 데이터라면 스토리지 엔진의 데이터에 접근하는 과정에서 같이 제외되는 편이 성능적으로 효율적이기 때문임
필터 조건으로 제거되는 데이터 비율을 확인하고 특정 SQL 문의 튜닝이 필요한지 판단할 수 있음
해당 비율은 실행 계획의 filtered 항목에서 확이할 수 있음

## 응용 용어
### selectivity
선택도란 테이블의 특정 열을 기준으로 해당 열의 조건절(WHERE)에 따라 선택되는 데이터 비율을 의미함.
만약 해당 열에 중복되는 데이터가 많다면 '선택도가 높다'고 평가할 수 있으며, 실제로 조건절에 따라 대량의 데이터가 선택될 것임
한편 해당 열에 중복데이터가 적당면 '선택도가 낮다'고 평가할 수 있음
조건절에 따라 매우 적은 양의 데이터가 선택될 것임

낮은 선택도를 가지는 열은 데이터를 조회하는 SQL문에서 원하는 데이터를 빨리 찾기 위한 인덱스 열을 생성할 때 주요 고려대상이 됨

이러한 선택도를 계산하는 수식은 다음과 같음
> 선택도 = 선택한 데이터 건수 / 전체 데이터 건수

선택하는 조건절의 데이터를 매번 계산할 수 없고 데이터 삭제와 수정, 삽입이 수시로 발생하는 만큼 보통은 중복이 제거된 데이터 건수를 활용하여 선택도를 일반화 시킴
> 변형된 선택도 = 1 / DISTINCT(COUNT 열명)

실제 학생 테이블에서 기본적인 선택도 수식을 활용하여 계산함
학생 테이블은 기본 키인 학번 열과 이름, 성별이라는 일반 열로 구성되어 있다고 가정함
이 테이블에는 총 100건의 데이터가 저장되어 있다면
학번 | 이름 | 성별

학번 열의 선택도의 계산방법
학번 열의 선택도 = 1 / 100 = 0.01
저장된 데이터는 총 100건으로 기본 키에 해당하는 학번 데이터는 어떤 학번을 선택하더라도 항상 하나의 유일한 값을 출력하는 0.01의 선택도를 가짐
다시 말해 학번은 0.01의 낮은 선택도를 가진다고 할 수 있음

다음 SQL 쿼리로 특정 열의 선택도를 구할 수 있음
```sql
SELECT COUNT(*)  -- 전체 데이터 건수 구하기
	FROM 테이블명;

SELECT COUNT(DISTINCT 열(column)명) -- 특정 열에서 중복을 제외한 개수 구하기
	FROM 테이블명;

SELECT 1 / COUNT(DISTINCT 열(coulmn)명) -- 선택도 구하기
	FROM 테이블명;
```

### cardinality
카디널리티의 사전적 정의는 '하나의 데이터유형으로 정의되는 데이터 행의 개수'

여기서는 전체 데이터에 접근한 뒤 출력될 것이라 예상되는 데이터 건수를 가리킴
현업에서는 전체 행에 대한 특정 열의 중복 수치를 나타내는 지표로 자주 활용함

카디널리티를 정확하게 계산하려면 앞서 다룬 선택도라는 개념이 필요함
카디널리티는 전체 데이터 건수에 해당 열의 선택도를 곱하여 계산이 가능함
열별 선택도를 알고 잇다면 카티널리티를 정량적 수치로 산출이 간으함

카디널리티 계산 공식
> 카디널리티 = 전체 데이터 건수 x 선택도

중복을 제외한 유일한 데이터 값의 수로 계산함
따라서 특정 열에 중복된 값이 많다면 카디널리티가 낮다고 할 수 있고 해당 열을 조회하면 상당수의 데이터를 거르지 못한 채 대량의 데이터가 출력되리라 예측할 수 있음

중복되는 값이 적다면 카디널리티가 높다고 평가가 가능함
그만큼 많은 데이터를 제거한 뒤 소수의 데이터만 출려되리라 예상이 가능함
중복도가 높으면 카디널리티가 낮고 중복도가 낮으면 카티널리티가 높다고 정리할 수 있음

### hint
힌트라는 말은 해당 문제에 대해 힌트를 듣는다면 정답을 더 쉽게 유추하거나 맞출수 있을 것임 마찬가지로 우리는 SQL 문으로 뒤죽박죽 섞인 데이터를 찾아내라는 어려운 문제를 풀어야함
데이터를 빨리 찾을 수 있도록 추가 정보를 전달하는게 힌트임

힌트 사용 방법
학생 테이블의 이름 열에 대한 학생_IDX01 (= 이름, 위치) 인 인덱스와
전공코드 열에 대한 학생_IDX02 (= 전공코드, 위치) 인덱스가 있다고 가정함.
인덱스는 각 행이 테이블의 기본 키 값을 가리킴

학번, 전공코드를 조회하는 SQL문임
```sql
SELECT 학번, 전공코드
	FROM 학생
	WHERE 이름 = '유재석';
```
학생_IDX01 인덱스를 활용하여 길을 찾아 달라는 힌트를 쿼리에 직접 작성이 가능함

1. 주석처럼 힌트를 명시하는 방법
   ```sql
   SELECT 학번, 전공코드
   FROM 학생 /*! USE INDEX (학생_IDX01) */
   WHERE 이름 = '유재석';
```
2. 주석 표기 없이 쿼리의 일부로 작성하는 방법
```sql
SELECT 학번, 전공코드
	FROM 학생 USE INDEX (학생_IDX01)
	WHERE 이름 = '유재석';
```

- 주요 힌트 목록

| 힌트            | 설명                               | 활용도 |
| ------------- | -------------------------------- | --- |
| STRAIGHT_JOIN | FROM  절에 작성된 테이블 순으로 조인을 유도하는 힌트 | 높음  |
| USE INDEX     | 특정 인덱스를 사용하도록 유도하는 힌트            | 높음  |
| FORCE INDEX   | 특정 인덱스를 사용하도록 강하게 유도하는 힌트        | 낮음  |
| IGNORE INDEX  | 특정 인덱스를 사용하지 못하도록 유도하는 힌트        | 중간  |
> 힌트 사용시 고려사항
> 힌트가 적용된 서비스 환경에서는 데이ㅓ 건수가 수시로 급변할 수 있고,
> 테이블이나 인덱스/뷰 등에 변화가 생기면 SQL 문 실행 시 오류가 발생할 가능성도 있습니다.
> 이때는 SQL 문에 힌트를 작성하면 별도로 관리해야함
```sql
SELECT *
	FROM 학생 USE INDEX(학생_IDX01)
	WHERE 이름 = ?;
```
SQL 문에 학생_IDX01 이라는 인덱스를 사용할 것이라는 USE INDEX 힌트를 작성하는 쿼리
```sql
ALTER TABLE 학생 DROP INDEX 학생_IDX01;
```
담당자가 학생_IDX01 인덱스를 불필요한 인덱스라고 판단하고 삭제하는 쿼리
이후 
```sql
SELECT *
	FROM 학생 USE INDEX(학생_IDX01)
	WHERE 이름 = ?;
```
위 코드를 실행하려 하면 인덱스가 삭제되었으므로 해당 SQL문을 실행하지 못하고 오류 메세지를 출력하는 쿼리가 발생하며 운영 서비스상 에러가 발생해 서비스 장애로 이어짐

## collation
콜레이션은 문자셋으로 데이터베이스에 저장된 값을 비교하거나 정렬하는 작업의 규칙을 의미함
문자의 경우 어떨지
- 소문자 a와 대문자 A 중에 무엇이 더 클지?
- 소문자 a와 소문자 b 중에 무엇이 더 클지?

이때 설정된 콜레이션에 따라 대소 관계의 출력도 달라지게 됨
utf8_bin : A, B, a, b 순으로 큼
utf8_general_ci : A, a, B, b

콜레이션은 데이터베이스 단위, 테이블 단위, 심지어 열단위까지 세세하게 설정이 가능함
만약 학생 테이블의 콜레이션이 utf8_general_ci로 설정되어 있다면,
학번 열과 전공 코드 열에 콜레이션이 명시되어 있지 않더라도 학생 테이블의 콜레이션인 utf8_feneral_ci가 적용됨
만약 이름 열에 콜레이션 utf8_bin을 명시했다면 상위 테이블의 콜레이션을 무시하고 utf8_bin으로 설정됨
즉, 이름 열은 콜레이션 utf8_bin이고 학번 열과 전공코드 열은 콜레이션 utf8_general_ci이 됨

테이블 생성 구문
```sql
CREATE TABLE '학생' (
	'학번' INT(10) NOT NULL,
	'이름' VARCHAR(10) NOT NULL COLLTAE 'utf8_bin',
	'전공코드' CHAR(2) NULL DEFAULT NULL,
	PRIMARY KEY ('학번')
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB
```

> 캐릭터셋 vs 콜레이션

| character set(캐릭터셋)                | collation(콜레이션)                           |
| ---------------------------------- | ----------------------------------------- |
| 데이터 저장을 어떻게 할 것인가?                 | 데이터 정렬을 어떻게 할 것인가?                        |
| - 영문 + 숫자                          | - a와 A 간의 대소관계 정의                         |
| - 중국어                              | - a와 b 간의 대소관계 정의                         |
| - 다국어                              | ...                                       |
| - 예) utf8(다국어), utf8mb4(다국어 + 이모지) | - 예) utf8_general_ci, utf8_bin(다국어 + 이모지) |

## 통계정보
옵티마이저는 통계정보에 기반을 두고 SQL 문의 실행 계획을 수립함.
통계정보는 데이터베이스 관리자DBA가 맡은 역할이긴 하지만, 쿼리를 수행하는 역할자 또한 통계정보가 현재 최신으로 관리되는지, 오래된 통계정보 때문에 SQL 문이 엉뚱한 방향으로 수행되지는 않는지를 확인할 수 있습니다.

MySQL은 시스템 변수를 통해 활용할 통계정보의 수준을 정의할 수 있음
기본적으로는 테이블 통계정보와 인덱스 통계정보, 선택적인 열 통계정보를 토대로 어떤 인덱스를 활용해 데이터에 액세스할 것인지, 어떤 테이블을 드라이빙 테이블로 선택할지 등을 결정.
통계정보의 최신성 유지 및 관리가 매우 중요함

## histgram
히스토그램은 테이블의 열값이 어떻게 분포되어 있는지 확인하는 통계정보입니다.
옵티마이저가 실행 계획을 최적화하고자 참고하는 정보로, 잘못된 히스토그램 정보가 있다면 잘못된 실행 계획으로 SQL문이 수행될 수 있습니다. 만약 특정 열값들의 통계정보가 히스토그램으로 수집되지 않았다면, 중복이 제거된 열값의 개수(COUNT (DISTINCT 열명))로 대략적인 열값의 분포를 예측하고 실행 계획을 수립

MySQL에서 내부적으로 열의 분포를 저장할 때는 height balaned histogram(높이균형 히스토그램)방식을 사용함. 즉, 저장된 데이터값의 종류가 수백, 수천, 수만 개 이상이므로 이 데이터 값들을 그룹화하고, 정해진 bucket 만큼 분리해서 열의 통계정보 데이터를 저장함
Col2 열을 대상으로 히스토그램이 어떤 방식으로 저장되는지를 보여줌
Col2 열에는 A, B, C, ..., ZZZ 까지 총 78종의 데이터와 10개의 버킷이 있다고 가정함
이때 Col2 열에 저장된 데이터들을 버킷 10개와 유사한 건수만큼 나눠 정렬함.
그림에 따르면 버킷 1에는 A, AA, AAA 데이터값이 분배되어 있고 버킷 2에는 B, BB, BBB, C, CC, CCC, D, DD, DDD, E, EE 가 분배되어 있음
> 데이터 건수가 같도록 그루핑 수행

실제 데이터베이스에서 관리하는 히스토그램의 버킷은 최댓값을 보관함
즉, 버킷 1에는 AAA, 버킷 2에는 EE, 버킷 3에는 H만 보관되는 것임
만약 WHERE 절 조건문에 Col1 = 'A'이라고 입력되어있다면 버킷 1에만 접근하여 데이터 분포를 파악함
또한 Col1 BETWEEN E AND O라고 작성된 조건절이 있다면, 
버킷 2부터 6까지 총 5개 버킷에 접근해야 함

이때 전체 데이터 대비 50% 이상의 영역을 스캔해야 하므로 인덱스 스캔보다 테이블 풀 스캔으로 쿼리가 수행되도록 통계정보를 제공함

> 히스토그램 정보 직접 생성하기
> MySQL
> 문법
> > ANALYZE TABLE 테이블명 UPDATE HISTOGRAM ON 열명 나열;
> 예시
> > ANALYZE TABLE 사원 UPDATE HISTOGRAM ON 이름;
> 확인
> > SELECT * FROM INFORMATION_SCHEMA.COLUMN_STATISTICS;
> 를 통해서 결과 확인
> 
> MariaDB
> 문법
> > ANALYZE TABLE 테이블명 PERSISTENT FOR COLUMNS (열명 나열) INDEXES(인덱스명 나열);
> 예시
> > ANALYZE TABLE 사원 PERSISTENT FOR COLUMNS (사원번호, 이름) INDEXES();
> 확인
> > SELECT * FROM mysql.column_stats;

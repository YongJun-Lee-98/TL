> 현재 상황에서 가장 좋아 보이는 것만을 선택하는 알고리즘

Greedy 알고리즘은 단순하지만 강력한 문제 해결 방법이다. 이 알고리즘 유형은 국내 알고리즘 교재에서 단어 그대로 탐욕법으로 소개된다.
어떠한 문제가 있을 때 단순 무식하게, 탐욕적으로 문제를 푸는 알고리즘이다.
탐욕적이라는 말은 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미함

매 순간 가장 좋아보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.
'사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형'이라는 특징이 있음

이후에 공부할 정렬, 최단 경로 등의 알고리즘 유형은 이미 그 알고리즘의 사용 방법을 정확히 알고 있어야만 해결 가능한 경우가 많음
데이터를 빠르게 정렬해야 하는 문제는 정렬 라이브러리의 사용 방법을 알고 있어야함
다른 예시로 최단 경로를 빠르게 찾아야 하는 문제는 플로이드 워셜 혹은 다익스트라 알고리즘과 같은 특정 알고리즘을 알고 있거나 팀 노트를 통해 준비해야 풀 수 있음
다익스트라 알고리즘은 엄밀히 말하면 그리디 알고리즘으로 분류되므로, 그리디 알고리즘이면서도 암기가 필요한 알고리즘이기도 하다.
이외에도 그리디 알고리즘 유형의 문제는 매우 다양하기 때문에 암기한다고 해서 항상 잘 풀 수 있는 알고리즘 유형이 아님
사전 지식 없이도 풀 수 있는 문제도 있겠지만, 많은 유형을 접해보고 문제를 풀어ㅇ보며 훈련해야함

그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 '가장 큰 순서대로', '가장 작은 순서대로'와 같은 기준을 알게 모르게 제시해준다. 대체로 이 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 그리디 알고리즘 문제는 자주 정렬 알고리즘과 짝을 이뤄 출제된다.

---

## 거스름돈
'가장 큰 화폐 단위부터' 돈을 거슬러 주는 것
N원을 거슬러 줘야 할 때, 가정먼저 500원으로 거술러 줄 수 있을 만큼 거슬러주고
그다음 100, 50, 10원 순으로 거슬러 줄 수 있을 만큼 거슬러 주면 된다.
1260원을 파이썬으로 거슬러주기

코드를 보면 화폐 종류만큼 반복을 수행해야 함
화폐의 종류가 K개라고 할 때 위 소스 코드의 시간 복잡도는 O(K)이다.
참고로 시간 복잡도에서 거슬러 주어야 할 돈 N은 찾아볼 수 없는 것을 알 수 있다.
이 알고리즘의 시간 복잡도는 동전의 총 종류에만 영향을 받고, 거슬러 줘야 하는 금액의 크기와는 무관하다는 것을 알 수 있다.
실제 코딩 테스트에서 출제되는 그리디 유형의 문제는 위와 같은 거스름돈 문제보다는 일반적으로 난이도가 높은 편이다.
문제에 접근하는 방법은 유사하므로 거스름돈 문제는 그리디 알고리즘을 설명할 때 자주 소개되는 문제이다.

## 그리디 알고리즘의 정당성
대부분의 문제는 그리디 알고맂므을 이용했을 때 '최적의 해'를 찾을 수 없을 가능성이 다분함
거스름돈 문제에서 '가장 큰 화폐 단위부터'돈을 거슬러 주는 것과 같이, 탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있따는 보장이 있을때는 매우 효과적이고 직관적
그리디로 찾았을 경우는 그 해법이 정당한지 검토해야한다.
거스름돈 문제를 그리디 알고지름으로 해결할 수 있는 이유는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문임
예를 들어 800원을 거슬러 줄 때 단위가 500, 400, 100 이라면 그리디로 풀경우는 500 + 100 + 100 + 100인데 사실상 정답이 400 + 400 을 거슬러주는 것임
이 문제에서는 큰 단위가 작은 단위의 배수 형태이므로, '가장 큰 단위의 화폐부터 가장 작은 단위의 화폐까지 차례대로 확인하여 거슬러 주는 작업만을 수행하면 된다'는 아이디어는 정당하다. 대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있다.

어떤 코딩테스트 문제를 만났을 때, 바로 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심하고, 문제를 해결할 수 잇는 탐욕적인 해결법이 존재하는지 고민해보자, 만약 오랜 시간을 고민해도 그리디 알고리즘으로 해결방법을 찾을 수 없다면, 그때는 이후의 장에서 다루게 될 다이나믹 프로그래밍이나 그래프 알고리즘 등으로 문제를 해결할 수 있는지를 재차 고민해보는 것도 한 방법이다.

처음 문제를 만났을 때 이것저것 다양하게 생각하고 고려해봐야한다.
가장 먼저 10원짜리로만 모두 거슬러 주도록 코드를 작성하며 어떻게 되지?
-> 이후에 10원으로만 모두 거슬러 주면 최적의 해를 구할 수 없겠구나 라고 문제점을 인식하고 가능한 또 다른 문제풀이 방법을 하나씩 곰곰이 생각해보는 것이다. 
'거스름돈 문제에서는 큰 단위가 항상 작은 단위의 배수 형태이므로, 이렇게 하면 항상 최적의 해를 보장할 수 있겠구나!'까지 떠올릴 수 있어야 정답 판정을 받을 수 있을 것임
실제로 거스름돈 문제에서 동전의 단위가 서로 배수 형태가 아니라 무작위로 주어진 경우에는 그리디 알고리즘으로 해결할 수 없다 화폐의 단위가 무작위로 주어진 문제는 2부에서 배울 다이나믹 프로그래밍으로 해결할 수 있으며 해당 문제 또한 책에서 다루고 있음
그리디 알고리즘의 기본 원리에 대해 알아보았으므로 그리디 알고리즘의 실전예제를 더 풀어보자
지금부터 설명할 문제는 알고리즘 대회 및 코딩 테스트에 출제되었던 문제르 ㄹ다듬은 것임
기업의 코딩 테스트를 안정적으로 통과하려면 다음에 소개되는 문제 각각에 대해 문제별 아이디어를 떠올리고 코드로 작성하기까지 시간이 30분 이내로 소요되어야 한다. 난이도는 모두 하 해당함

큰 수의 법칙
일반적으로 통계 분야에서 다루어지는 내용이지만 도입니은 본인마의 방식으로 다르게 사용하고 있음
다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰수를 만드는 법칙이다.
단 배열의 특정한 인데스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.

2,4,5,4,6 으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정
이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6 6 6 5 6 6 6 5인 46이된다.

단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주함
ex 순서대로 3,4,3,4,3으로 이루어진 배열이 이씅ㄹ 때 M이 7이고 K가 2라고 가정하자 이 경우 두번째 원소에 해당하는 4와 네번째 원소에 해당하는 4를 번갈아 두번씩 더하는 것이 가능하다. 결과적으로 4 4 4 4 4 4 4 = 28이 도출된다.

배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오
> 입력조건
> 첫째 줄에 N(2<= N <= 1,000), M(1<= M <= 10,000), K(1<= K <= 10,000)의 자연수가 주어지며, 각 지연수는 공백으로 구분한다.
> 
> 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단 각각의 자연수는 1 이상 10,000이하의 수로 주어진다.
> 입력으로 주어지는 K는 항상 M보다 작거나 같다.

출력 조건 - 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

전형적인 그리디 알고리즘 문제로, 문제를 해결을 위한 아이디어를 떠올리는 것은 어렵지 않은편임
문제 해결을 위한 아이디어를 떠올렸어도 구현 실수로 인해 오답 처리를 받는 경우가 많은 문제이므로 꼭 집접 작성해봐야함

이 문제르 해결하려면 일단 입력값 중에서 가장 큰 수와 두번째로 큰 수만 저장하면 된다.
연속으로 더할 수 있는 횟수는 최대 K번이므로 가장 큰수를 K번 더하고 두번째로 큰 수를 한 번 더하는 연산을 반복하면 된다.

간단한 수학적 아이디어를 통해 더 효율적으로 문제를 해결하기
가장 큰 수와 두 번째로 큰 수를 선택한 뒤
반복되는 수열에 대해서 파악해야 한다. 가장 큰 수와 두 번째 큰수가 더해질 때는 특정한 수열 형태로 일정하게 반복해서 더해지는 특징이 있다.
반복되는 수열의 길이는 어떻게 될까?
(K+1)로 나눈 몫이 수열이 반복되는 횟수가 됨
M을 (K+1)로 나눈 몫이 수열이 반복되는 횟수가 됨
여기에 K를 곱해주면 가장 큰 수가 등장하는 횟수가 됨

가장 큰 수가 더해지는 횟수
int(M / (K+1)) * K + M % (K + 1)

---
## 숫자 카드 게임
숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한장으 ㄹ뽑는 게임
게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같음

1. 숫자가 쓰인 카드들이 N x M 형태로 놓여 있다. 이때 N은 행의 개수, M은 열의 개수이다.
2. 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다.
3. 그다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야한다.
4. 따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야함

카드를 골라낼 행을 고를 때 첫 번째 혹은 두 번째 행을 선택하는 경우 최종적으로 뽑는 카드는 1이다. 하지만 세번째는 최종적으로 뽑는 카드는 2이다. 따라서 이 예제에서는 2가 쓰여진 카드를 뽑는 것이 정답임
카드들이 N x M 형태로 놓여 있을 때, 게임의 룰에 맞게 카드를 뽑는 프로그램을 만드시오

- 입력조건 첫째 줄에 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 하여 각각 자연수로 주어짐 ( 1 <= N,M <= 100)
- 둘째 줄부터 N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어진다. 각 숫자는 1 이상 10,000 이하의 자연수 이다.
- 첫째 줄에 게임의 룰에 맞게 선택한 카드에 적힌 숫자를 출력한다.

입력 예시
3 3 N M
3 1 2
4 1 4
2 2 2

```python
n, m = map(input().split())

result = 0

for i in range(n):
	data = list(map(int, input().split()))
	min_value = 10001
	for a in data:
		min_value = min(min_value, a)
	result = max(result, min_value)

print(result)
```
가장 큰 값과 입력한 데이터를 비교하고
이를 토대로 가장작은 값을 구하고
result는 큰 값을 반환해야하므로 max를 통해 저장한다.

---
## 1이 될 때까지
어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려 한다.
단, 두 번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다.
1. N에서 1을 뺀다.
2. N을 K로 나눈다.
예를 들어 N이 17, K가 4라고 하면 1 번을 수행하면 N은 16이 되고 2번을 두번 수행하면 1이 된다.
이 경우 전체 과정을 실행한 횟수는 3이 된다. 이는 N을 1로 만드는 최소 횟수이다.

N과 K가 주어질 때 N이 1이 될때까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하시오

입력조건
- 첫째 줄에 N(2<= N <= 100,000)과 K(2 <= K <= 100,000)가 공백으로 구분되며 각각 자연수로 주어진다.
  이때 주어지는 N은 항상 K보다 크거나 같다.
출력조건
- 첫째 줄에 N이 1이 될때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력한다.

직접 구현한 코드 ㅎㅎ
```python
# 1이 될때까지
n, k = map(int, input().split())

count = 0

while True:
	# 나머지 수는 -1횟수와 나누는 동작 횟수로 +1을 해줌
	count += n % k + 1
	n = n // k
	if n < k:
		# 1까지 빼야하니까 횟수는 1개가 적게해줌
		count += n - 1
		break
print(count)
```

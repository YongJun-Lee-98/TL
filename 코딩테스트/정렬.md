연속된 데이터를 기준에 따라서 정렬하기 위한 알고리즘
# 기준에 따라 데이터를 정렬
## 정렬 알고리즘 개요
Sorting 이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말함
프로그램에서 데이터를 가공할 때 오름차순이나 내림차순 등 대부분 어떤 식으로든 정렬해서 사용하는 경우가 많음 정렬 알고리즘은 프로그램을 작성할 때 가장 많이 사용되는 알고리즘 중 하나다. 정렬 알고리즘으로 데이터를 정렬하면 다음장에서 배울 이진 탐색이 가능해짐
정렬 알고리즘은 이진 탐색의 전처리 과정이기도 하니 제대로 알고 넘어가기

정렬 알고리즘은 굉장히 다양한데 이 중에서 많이 사용하는 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬만 이 책에서 언급하려 한다.
더불어 파이썬에서 제공하는 기본 정렬 라이브러리를 적용하여 좀 더 효과적인 정렬 수행 방법도 다룸

보통 정렬부터 공부하면 알고리즘의 효율성을 쉽게 이해할 수 잇어 알고리즘 개론서 초반에 정렬 알고리즘을 설명하는 경우가 많음 일반적으로 문제에서 요구하는 조건에 따라서 적절한 정려 알고맂므이 공식처럼 사용됨
상황에 적절하지 못한 정렬 알고리즘을 이용하면 당연히 프로그램은 비효율적으로 동작하며 필요 이상으로 시간을 많이 소요한다. 그래서 정렬 알고리즘을 공부하다 보면 자연스럽게 알고리즘 효율의 중요성을 깨닫는다.
정렬 또한 면접에서도 단골 문제로 출제된다는 점을 기억하자
카드 예제를 기준으로 이번 장에서는 정렬 알고리즘을 설명함 이 장에서 다루는 예제는 모두 오름차순 정렬을 수행한다고 가정한다. 내림차순 정렬은 오름차순 정렬을 수행하는 알고리즘에서 크기 비교를 반대로 수행하면 된다.
파이썬에서는 특정한 리스트의 원소를 뒤집는 메서드를 제공한다. 그래서 내림차순 정렬은 오름차순 정렬을 수행한 뒤에 그 결과를 뒤집기 하여 내림차순 리스트로 만들 수 있다.

## 선택정렬
컴퓨터가 데이터를 정렬할 때 어떻게 할지 한 번 생각해보자.
데이터가 무작위로 여러 개 있을 때, 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복하면 어떨까?
이 방법은 가장 원시적인 방법으로 매번 '가장 작은 것을 선택'하겠다는 의미에서 Selection Sort 알고리즘이라고 한다.
가장 작은 것을 선택해서 앞으로 보내는 과정을 반복해서 수행하다 보면, 전체 데이터의 정렬이 이루어진다. 이해를 도빅 위해 예제를 통해 자세한 동작 원리를 확인함
정렬 알고리즘에서 흔히 데이터의 개수를 N이라고 하면 N = 10 인 경우를 가정함
현재 정렬되지 않은 데이터 중 가장 작은 데이터를 의미하며 하늘 색 카드는 이미 정렬된 데이터를 뜻함

```python
array = \[7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
for i in range(len(array)):
	min_index = i # 가장 작은 인덱스
	for j in range(i+1, len(array)):
		if array[min_index > array[j]]:
			min_index = j
	array[i], array[min_index] = array[min_index], array[i] # 스와프

print(array)
```

이 코드는 Swap에 대해서 모른다면 이해하기 어려운 부분이 있음
특정한 리스트가 주어졌을 때 두 변수의 위치를 변경하는 작업을 의미한다.
파이썬에서는 간단히 리스트 내 두 원소의 위치를 변경할 수 있다.
다른 대부분의 프로그래밍에서는 임시 저장용 변수를 만들어 두 원소의 값을 변경하여야한다.

array = \[3, 5]
array\[0], array\[1] = array\[1], array\[0]

print(array)

다른 언어에서도 별도의 스와프 함수가 있지만 파이썬만큼 간편하지는 않음
C 언어에서 표준 라이브러리를 활용하지 않고 2개의 변수 a와 b의 값을 서로 교체하도록 작성한 코드는
```c
int a = 3;
int b = 5;

// 스와프 진행
int temp = a;
a = b;
b = temp;
```
#### 선택정렬의 시간복잡도
선택 정렬은 N - 1 번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야함
매번 가장 작은 수를 찾기 위해서 비교 연산이 필요함 구현 방식에 따라서 사소한 오차는 있을 수 있으나 앞쪽의 그림대로 구현시에는 연산 횟수는 N + (N-1) + (N-2) + ... + 2 로 볼 수 있음

따라서 근사치로 N x (N+1)/ 2 번의 연산을 수행한다고 가정하고 이는 (N^2 + N)/2 로 표현이 가능한데
빅오 표기법으로 간단히 O(N^2)라고 표현할 수 있음
빅오 표기법은 1장의 '시간복잡도'에서 설명했음
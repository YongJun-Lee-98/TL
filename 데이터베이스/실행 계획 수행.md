실행 계획은 SQL문으로 요청한 데이터를 어떻게 불러올 것인지에 관한 계획, 즉 경로를 의미함
지름길을 사용해 데이터를 빠르게 찾아낼 것인지, 지름길이 있어도 멀리 돌아가서 찾을 것인지 미리 확인이 가능함

## 기본 실행 계획 수행
### 실행 계획 키워드
EXPLAIN, DESCRIBE, DESC 가 있음
> EXPLAIN SQL 문;
> DESCRIBE SQL 문;
> DESC SQL 문;

임의의 SQL문에 관한 실행계획을 확인

#### MySQL
SQL문 앞에 EXPLAIN 키워드를 입력하고 실행하면 옵티마이저가 만든 실행 계획이 출력됨
EXPLAIN 대신 DESCRIBE나 DESC 키워드를 입력해도 됨
MariaDB에 비해 partitions, filtered 열이 추가되면서 더 많은 정보를 보여줌
```mysql
mysql > EXPLAIN
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 100001 AND 200000;
```

#### MariaDB
SQL문 앞에 EXPLAIN, DESCRIBE, DESE 키워드를 입력하면됨
UPDATE 및 DELETE 문에서도 실행 계획을 확인이 가능함
```sql
EXPLAIN
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 100001 AND 200000;
```

출려되는 정보에는 차이가 있지만, 실행 계획을 해석하고 SQL 튜닝을 수행하는 과정 자체에는 크게 영향을 주지 않음

## 기본 실행 계획 항목 분석
출력되는 항목의 의미를 이해해야함
SQL 문이 비효율적으로 수행되지는 않는지, 튜닝을 어떻게 해야할지 등에 관한 방향을 잡도록하낟.
### id
실행 순서를 표시하는 숫자, SQL문이 수행되는 차례를 ID로 표기한 것으로, 조인할 때는 똑같은 ID가 표시됨
ID의 숫자가 작을 수록 먼저 수행된 것이고 ID가 같은 값이라면 두 개 테이블의 조인이 이루어졌다고 해석이 가능함

ID가 1인 첫 번째 행과 두 번째 행의 조인이 이루어진 뒤에 세번째 행이 수행된 것이라고 짐작이 가능함

### select_type
SQL문을 구성하는 SELECT 문의 유형을 출력하는 항목
SELECT 문이 단순히 FROM 절에 위치한 것인지, 서브쿼리인지, UNION 절로 묶인 SELECT 문인지 등의 정보를 제공함

#### | SIMPLE |
UNION이나 내부 쿼리가 없는 SELECT 문이라는 걸 의미하는 유형
말 그대로 단순한 SELECT 구문으로만 작성된 경우를 가리킴

#### | PRIMARY |
서브쿼리가 포함된 SQL 문이 있을 때 첫 번째 SELECT 문에 해당하는 구문에 표시되는 유형
서브 쿼리를 감싸는 외부 쿼리이거나, UNION이 포함된 SQL 문에서 첫 번째로 SELECT 키워드가 작성된 구문에 표시됨

> |PRIMARY|~~~ | const | PRIMARY |
> |SUBQUERY| ~~~ | index | NULL |
> 
> ---

| key      | key_len | ref   | rows   | filtered | Extra       |
| -------- | ------- | ----- | ------ | -------- | ----------- |
| PRIMARY  | 4       | const | 1      | 100.00   | NULL        |
| 인덱스_부서번호 | 16      | NULL  | 331143 | 100.00   | Using index |

UNION ALL 구문으로 통합된 SQL 문에서
처음 SELECT 구문이 작성된 쿼리가 먼저 접근한다는 의미로 PRIMARY가 출력됨

```sql
EXPLAIN
SELECT 사원1.사원번호, 사원1.이름, 사원1.성
FROM 사원 as 사원1
WHERE 사원1.사원번호 = 100001

UNION ALL

SELECT 사원2.사원번호, 사원2.이름, 사원2.성
FROM 사원 as 사원2
WHERE 사원2.사원번호 = 100002;
```

#### | SUBQUERY |
독립적으로 수행되는 서브쿼리를 의미함.
다음 예제에서는 메인쿼리의 SELECT 절에 정의된 부서사원_매핑 테이블과 급여 테이블에 대해 옵티마이저가 서브쿼리임을 인지하고 있음을 알 수 있음
SELECT 절의 스칼라 서브쿼리와 WHERE 절의 중첩 서브쿼리일 경우에 해당
```sql
EXPLAIN
SELECT (SELECT COUNT(*)
	   FROM 부서사원_매핑 as 매핑) as 카운트,
	   (SELECT MAX(연봉)
	   FROM 급여) as 급여;
```

| id  | select_type | table | partitions | type  | possible_keys | key    |
| --- | ----------- | ----- | ---------- | ----- | ------------- | ------ |
| 1   | PRIMARY     | NULL  | NULL       | NULL  | NULL          | NULL   |
| 3   | SUBQUERY    | 급여    | NULL       | ALL   | NULL          | NULL   |
| 2   | SUBQUERY    | 매핑    | NULL       | index | NULL          | I_부서번호 |

| key_len | ref  | rows    | filtered | Extra          |
| ------- | ---- | ------- | -------- | -------------- |
| NULL    | NULL | NULL    | NULL     | No tables used |
| NULL    | NULL | 2838731 | 100.00   | NULL           |
| 12      | NULL | 331143  | 100.00   | Using index    |
#### | DERIVED |
FROM 절에 작성된 서브쿼리라는 의미
즉, FROM 절의 별도 임시 테이블인 인라인 뷰를 말함
다음 쿼리는 메인쿼리의 FROM 절에서 급여 테이블의 데이터를 가져오는 인라인 뷰임
해당 인라인 뷰는 실행 계획을 통해 두 번째로 수행되고 있다는 걸 알 수 있음

#### | UNION |
UNION 및 UNION ALL 구문으로 합쳐진 SELECT 문에서 첫 번째 SELECT 구문을 제외한 이후의 SELECT 구문에 해당한다는 걸 나타냄
이때 UNION 구문의 첫 번째 SELECT 절은 PRIMARY 유형으로 출력됨
MySQL이라는 DBMS는 데이터를 저장하고, 저장된 데이터를 가공하는 연산을 수행함

실행된 SQL문은
1. DB에 존재하는 테이블 대상으로 SQL문을 작성했는지 확인
2. 다양한 문법 및 구문으로 검사(파싱 작업을 하는 parser 역할)
3. 사용자가 요청한 데이터를 빠르고 효율적으로 찾는 전략적 계획을 수립함(optimizer 역할)
4. 스토리지 엔진에 위치한 데이터까지 찾아간 뒤 해당 데이터를 MySQL 엔진으로 전달
5. MySQL 엔진은 전달된 데이터에서 불필요한 부분을 필터링하고 필요한 연산을 수행한 뒤 사용자에게 최종 결과를 알려줌

## 스토리지 엔진
(InnoDB, MyISAM, Memory 등) 스토리지 엔진은 사용자가 요청한 SQL문을 토대로 DB에 저장된 디스크나 메모리에서 필요한 데이터를 가져오는 역할을 수행함
이후 해당 데이터를 MySQL 엔진으로 보내줌
스토리지 엔진이 데이터를 저장하는 방식에 따라 각각의 스토리지 엔진을 선택하여 사용할 수 있음
필요하다면 외부에서 스토리지 엔진 설치 파일을 가져와 활성화 하여 즉시 사용 가능

일반적인 온라인상의 트랜잭션 발생을 데이터를 처리하는 것은 OLTP(online transaction processing)환경이 대다수 주로 InnoDB 엔진을 사용함
대량의 쓰기 트랜잭션이 발생하면 MyISAM 엔진을
메모리 데이터를 로드하여 빠르게 읽는 효과를 내려면 Memory 엔진을 사용하는 식으로 응용하여 스토리지 엔진을 선택할 수 있음

SQL 튜닝은 일반적인 OLTP 환경에서 사용하는 InnoDB 엔진 중심으로 설명
mysql > SELECT ENGINE, TRANSACTIONS, COMMENT FROM information_Schema.engines;

## MySQL 엔진
MySQL 엔진은 사용자가 요청한 SQL문을 넘겨받은 뒤 SQL 문법 검사와 적절한 오브젝트 활용 검사를 하고 SQL 문을 최소 단위로 분리하여원하는 데이터를 빠르게 찾는 경로를 모색하는 역할을 수행함

사용자가 SQL문을 수행하면 파서는 MySQL이 이해할 수 있는 최소 단위로 구성요소를 분리하고 구성요소를 트리로 만듦
트리를 만드는 과정에서는 문법 오류가 있는지 검토합니다.

트리의 최소 단위는 >, <, = 등의 기호나 SQL 키워드로 분리함
만약 트리에 허용되지 않는 문법이 포함된다면 에러 발생과 동시에 실행이 종료됩니다.

### 파서
parser는 MySQL 엔진에 포함되는 오브젝트로, 사용자가 요청한 SQL 문을 쪼개 최소 단위로 분리하고 트리를 만듭니다.
트리를 만들면서 문법 검사를 수행

### 전처리기
preprocessor는 MySQL 엔진에 해당하는 오브젝트로, 파서에서 생성한 트리를 토대로 SQL 문에 구조적인 문제가 없는지 파악
SQL 문에 작성된 테이블, 열, 함수, 뷰와 같은 오브젝트가 실질적으로 이미 생성된 오브젝트인지, 접근 권한은 부여되어 있는지 확인하는 역할

### 옵티마이저
optimizer는 MySQL 의 핵심 엔진 중 하나로, DBMS에서 두뇌라고 불러도 과언이 아님
전달된 파서 트리를 토대로 필요하지 않은 조건은 제거하거나 연산 과정을 단순화함
모든 실행 계획을 판단하지는 않습니다. 이는 옵티마이저가 선택한 최적의 실행 계획이 최상의 실행 계획이 아닐 가능성도 있다는 것을 의미
실행 계획을 수립하는 작업 자체만으로도 사용자의 대기 시간과 하드웨어 리소스를 점유하므로
시간과 리소스에 제한을 두고 실행 계획을 선정해야 함

### 엔진 실행기
engine executor 는 MySQL 엔진과 스토리지 엔진 영역 모두에 걸치는 오브젝트
MySQL 엔진에서는 읽어온 데이터를 정렬하거나 조인하고, 불필요한 데이터는 필터링 처리하는 추가 작업을 함

MySQL 엔진의 부하를 줄이려면 스토리지 엔진에서 가져오는 데이터양을 줄이는 게 매우 중요합니다.

## DB 오브젝트 용어
### 테이블
table 은 데이터를 저장하는 오브젝트로 행과 열의 정보를 담습니다.
테이블에서는 저장방식과 저장 구조에 따라 스토리지 엔진 속성을 정의할 수 있음
InnoDB 스토리지 엔진은 보통 OLTP 환경에서 주로 사용하는 기본 DB 엔진이며 그외에도 MyISAM, Memory, Blackhole 엔진 등이 있습니다.

### 로우행
row 는 행에 해당하는 용어, 테이블에서 동일한 구조의 데이터 항목들의 집합을 가리킴
다른 행 역시 데이터의 값 자체는 다르지만 데이터 항목의 구조는 동일함
즉, 행은 하나의 데이터 항목 집합이며 모든 행의 집합을 테이블이라고 할 수 있음

행 수가 많아지면 데이터에 접근하는 과정에서 시간이 오래 소요될 가능성이 높음
이때 **파티셔닝** 기법으로 SQL 문의 성능 향상을 검토해볼 수 있음

### 컬럼(열)
column 열에 해당하는 용어 사전에 정의한데이터값을 저장하며,
열별로 다른 데이터 유형을 가질 수 있음
학생 테이블에서 학번 열은 숫자형 데이터로 정의하고 이름은 문자열 유형으로 정의함을 알 수 있음

### 기본 키
primary key(PK) 특정 행을 대표하는 열을 가리키는 용어로 주 키라고도 함
어떤 행과도 중복되지 않는 대푯값
전공테이블의 전공코드처럼 각 테이블에서 1개 열만으로 생성하지만 상황에 따라 2개 이상의 열을 조합해 기본 키를 구성할 수도 있음
향후 인덱스 역할도 수행하므로 기본키를 활용하여 인덱싱할 수 있음을 알고 있어야함

MySQL/MariaDB에서 기본 키는 클러스터형 인덱스(clustered index)로 작동함.
이는 기본 키의 구성 열 순서를 기준으로 물리적인 스토리지에 데이터가 쌓인다는 뜻
즉, 비슷한 기본 키 값들이 근거리에 적재되므로 기본 키를 활용하여 인덱스 스캔을 수행하면 테이블 데이터에 더 빠르게 접근이 가능하게됨

### 외래 키
foreign key(FK)
외부에 있는 테이블을 항상 참조하면서, 외부 테이블의 데이터가 변경되면 함께 영향을 받는 관계를 설정하는 키, 여기서 외부 테이블을 부모테이블, 외부 테이블을 참조하는 테이블을 자식 테이블이라고 생각하면 쉬움

## 인덱스
index 는 데이터베이스에서 키값으로 실제 데이터 위치를 식별하고 데이터 접근 속도를 높이고자 생성되는, 키 기준으로 정렬된 오브젝트임

정렬된 각 키워드가 어느 곳에 있는지를 인덱스라는 이름으로 구성하면, 키워드 검색으로 원하는 페이지를 빠르게 찾을 수 있음


실제 데이터는 뒤죽박죽 저장되지만 MySQL 특성상 기본 키 (PK) 기준으로 데이터가 쌓임

인덱스는 생성하려는 열의 속성에 따라 고유 인덱스 (unique index)와 비고유 인덱스 (non-unique index)로 구분이 가능함
흔히 거론되는 인덱스는 비고유 인덱스입니다.

### 고유 인덱스
데이터가 유일하다는 의미
차례로 정령되는 인덱스 열의 데이터는 서로 중복되지 않고 유일성을 유지함. 만약 동일한 데이터가 생성되면 고유 인덱스의 중복 체크 과정에서 에러가 발생함
중복이 없는 열들을 고유 인덱스로 생성하려 한다면 중복이 있는지 검증하는 절차를 걸쳐야 하므로 불필요한 중복 검증 과정이 추가되니 주의해야함

타인과 동일한 연락처가 등록되는 일을 방지하고자 연락처 열을 고유 인덱스로 생성함
    기본 키와 고유 인덱스의 차이점
	모두 유일성을 보장해야 하는 특성과 효율적인 데이터 접근을 위한 인덱스로의 수단으로 사용되기 때문임. 다만 기본키에는 NULL을 입력할 수 없지만 고유 인덱스에는 입력이 가능하다는 차이점이 존재함

> ALTER TABLE 학생
> ADD UNIQUE INDEX 연략처_인덱스(연락처);
### 비고유 인덱스
non-unique index
고유 인덱스에서 데이터의 유일한 속성만 제외한 키
데이터가 신규 입력되어 인덱스가 재정렬되더라도 인덱스 열의 중복 체크를 거치지 않고 단순한 정렬 작업을 수행함
학생 테이블의 이름 열을 비고유 인덱스로 지정
시스템에서 이름 열을 기준으로 조회하는 경우가 자주 발생한다고 가정함
이때 이름이라는 데이터 속성은 중복이 발생할 수 있으므로 일반적인 인덱스 형태, 즉 비고유 인덱스를 생성

> ALTER TABLE 학생
> ADD INDEX 이름_인덱스(이름);

## 뷰
view
일명 가상 테이블이라고 이해하면 됨
물리적으로 잡히지 않는 유령과 같은 오브젝트
일상생활에서 예를 들자면, 올림픽 경기장에서 열리는 콘서트에 참석하지 못하는 대신 실시간 스트리밍으로 해당 콘서트를 관람하는 상황을 가정해볼 수 있음
실제 올림픽 경기장에서 열리는 콘서트장을 '테이블'
실체는 없지만 간접적으로 대상을 확인할 수 있는 스트리밍 방식을 '뷰'라고 할 수 있음

학생 테이블 뷰를 만드는 예제
학생 테이블에는 5개의 열이 있지만
뷰에서는 학번 및 이름 데이터만 조회하도록 생성

학생 테이블의 데이터가 변경되면 학생 뷰에서도 바로 변경된 데이터를 조회가 가능함
반대로 학생 뷰에서 데이터를 변경(update)하면 학생 테이블의 해당 데이터도 즉시 변경됨
생성된 뷰를 대상으로 개발자는 'SELECT * FROM 학생_뷰;'
그 결과는 'SELECT 학번, 이름 FROM 학생;'
```sql
CREATE VIEW 학생_뷰 AS
SELECT 학번, 이름 FROM 학생;
```

### 뷰를 사용하는 이유
뷰를 사용하는 이유는 일부 데이터에 대해서만 데이터를 공개하고, 노출에 민감한 데이터에 대해서는 제약을 설정할 수 있는 보안성 때문.
여러 개의 테이블을 병함(join)해서 활용할 때는 성능을 고려한 최적화된 뷰를 생성함으로써 일관된 성능을 제공할 수 있음

## 논리적인 SQL 개념 용어
학생 테이블에는 학번, 이름, 전공코드 열이 있고 지도 교수 테이블에는 학번과 지도교수명 열이 있음

정리
1명의 학생은 1명의 교수에게만 소속되며 1명의 교수는 1명의 학생만을 지도할 수 있는 환경

### 서브쿼리 위치에 따른 SQL 용어
subquery란 쿼리 안의 보조 쿼리를 가리키는 용어임
SELECT 문인 mainquery를 기준으로 내부에 SELECT 문을 추가로 작성해서 서브쿼리를 만든다.
SELECT 문 안쪽에 위치한 SELECT 문은 어느 위치에 작성되었는지에 따라 부르는 용어가 달라짐
```sql
SELECT (SELECT ... FROM) <- SELECT절: 스칼라 서브쿼리
	FROM (SELECT ... FROM ...) <-FROM절: 인라인 뷰
WHERE 컬럼명 IN (SELECT ...FROM...) <- WHERE 절: 중첩 서브쿼리
```

### scalar subquery
메인쿼리의 SELECT 절에 있는 또 다른 SELECT 절이 스칼라 서브쿼리라고 앞서 설명했음
FROM 절이나 WHERE 절 등에서도 스칼라 서브쿼리를 사용할 수 있으나, 대부분의 SQL문에서 SELECT 절을 사용하므로 본 SELECT 절에 작성된 SELECT문을 기준으로 설명함.
메인쿼리의 SELECT 절에는 최종 출력하려는 열들이 나열되므로, 출력 데이터 1건과 스칼라 서브쿼리의 결과 건수가 일치해야함. 
만약 스칼라 서브쿼리의 결괏값이 2개 이상 나온다면 에러가 발생할 것
즉 스칼라 서브쿼리의 결괏값은 1행 1열의 구조로 출력되어야함
```sql
SELECT 이름,
		(SELECT COUNT(*)
			FROM 학생 AS 학생2
			WHERE 학생2.이름 = 학생1.이름) 카운트
	FROM 학생 AS 학생1;
```

### inline view
메인쿼리의 FROM 절에 있는 또 다른 SELECT 절이 인라인 뷰라고 앞서 설명했음
FROM 절 내부에서 일시적으로 뷰를 생성하는 방식이므로 인라인 뷰라고 불림
인라인 뷰의 결과는 내부적으로 메모리 또는 디스크에 임시 테이블을 생성하여 활용함

### nested subquery(중첩서브쿼리)
메인쿼리의 WHERE 절에 있는 또 다른 SELECT 절을 중첩 서브쿼리라고 앞서 설명함
WHERE 절에서 단순한 값을 비교 연산하는 대신, 서브쿼리를 추가하여 비교 연산하기 위해 중첩 서브쿼리를 사용함
이처럼 WHERE 절에서 중첩 서브쿼리와 비교할 때는 보통 비교 연산자를 비롯해 IN, EXISTS, NOT, EXISTS 문을 많이 사용함

## 메인쿼리와의 관계성에 따른 SQL 용어
### non correlated subquery (비상관 서브쿼리)
메인쿼리와 서브쿼리간에 관계성이 없음을 의미함 서브쿼리가 독자적으로 실행된 뒤 메인 쿼리에게 그 결과를 던져주는 형태인 것임.
지도교수 테이블에 대한 서브쿼리는 독자적으로 수행 가능한 형태로, 지도교수 테이블에서 원하는 데이터를 가져온 뒤에 메인쿼리가 수행됨

서브쿼리 실행 -> 메인쿼리 실행의 순서로 실행됨
비상관 서브쿼리는 성별 = '남' 조건으로 학생 테이블에서 데이터를 가져온 뒤 그 결과를 메인쿼리의 학생 테이블로 전달하여 최종 데이터를 출력함 이때 DB 버전 및 옵티마이저에 따라 서브쿼리가 제거되고 하나의 메인쿼리로 통합되는 뷰 병합 (view merging), 즉 SQL 재작성이 작동할 수도있음

### correlated subquery (상관 서브쿼리)
메인쿼리와 서브쿼리간의 관계성이 있음을 의미함
서브쿼리가 수행되면 메인쿼리의 값을 받아야 하므로 서브쿼리와 메인쿼리는 서로 끈끈한 관계를 유지함
이러한 상관 서브쿼리는 SELECT 절에 작성하는 스칼라 서브쿼리와 WHERE 절에 작성하는 중첩 서브쿼리일 때 발생함
```sql
SELECT *
	FROM 학생
WHERE 학번 IN (SELECT 학번
					FROM 지도교수
					WHERE 성별 = 지도교수.학번 = 학생.학번)
```

## 반환결과에 따른 SQL 용어
### single-row subquery (단일행 서브쿼리)
서브쿼리 결과가 1건의 행으로 반환되는 쿼리
```sql
SELECT ...
	FROM ...
	WHERE 학번 = (SELECT MAX(학번) FROM 학생)
```

### multi-row subquery (복수행 서브쿼리)
서브쿼리 결과가 여러 건의 행으로 반환되는 쿼리
메인 쿼리의 조건절에서 IN 구문으로 서브쿼리에서 반환되는 값을 받음
```sql
SELECT ...
	FROM ...
WHERE 학번 IN (SELECT MAX(학번)
				FROM 학생
				GROUP BY 전공코드);
```

### multiple-column subquery (다중열 서브쿼리)
서브쿼리 결과가 여러 개의 열과 행으로 반환됨
그에 따라 메인 쿼리의 조건절에서는 IN 구문과 함께 서브쿼리에서 반환될 열들을 동일하게 나열해서 서브쿼리 결과를 받음
```sql
SELECT ...
	FROM ...
	WHERE (이름, 전공코드)
		IN (SELECT 이름, 전공코드
			FROM 학생
			WHERE 이름 LIKE '김%') <- 출력값이 두개이상의 컬럼을 출력하는 서브쿼리
```

## 조인 연산방식 용어
DB에는 다수 테이블이 있고 필요한 데이터도 여기저기 흩어져 있음
이때 필요한 데이터끼리 결합할 때 join(조인)이라고 한다.
분리된 데이터 간의 공통된 정보, 즉 동일한 열 값 또는 키값 기준으로 데이터를 논리적으로 연결할 수 있음
![[../../../IMG_0316.jpeg]]
### inner join (내부조인)
양쪽 테이블에 같은 데이터가 있을 때만 결합하는 방식
학생 테이블과 지도교수 테이블이 기본적으로 일대일 관계를 유지하며,
지도교수가 확정되지 않은 학생은 지도교수 테이블 해당 학번이 없을 수 있고, 자퇴한 학생의 정보는 지도교수 테이블에 아직 남아 있을 수 있음 이러한 예제와 가정은 조인 연산 방식의 이해를 돕는 수단이지만 실제 현업의 예제로는 적절하지 않을 수 있음

학생 = [1, 2, 3, 4]
지도교수 = [1, 2, 4, 99]

내부조인 - 조인을 명시적으로 표현한 경우
```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
	FROM 학생
	JOIN 지도교수
		ON 학생.학번 = 지도교수.학번
```

내부조인 - 조인을 암시적으로 표현한 경우
```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
	FROM 학생, 지도교수
	WHERE 학생.학번 = 지도교수.학번
```

### left outer join (왼쪽 외부 조인) / right outer join (오른쪽 외부조인)
각각 어느 한쪽에만 데이터가 있으도 데이터를 결합하는 방식
학생 = [1, 2, 3, 4]
지도교수 = [1, 2, 4, 99]

> 왼쪽 외부 조인
> LEFT OUTER JOIN or LEFT JOIN
```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
	FROM 학생
	LEFT OUTER JOIN 지도교수
		ON 학생.학번 = 지도교수.학번
```

> 오른쪽 외부 조인
> RIGHT OUTER JOIN or RIGHT JOIN
```sql
SELECT 지도교수.학번, 학생.이름, 지도교수.교수명
	FROM 학생
	RIGHT OUTER JOIN 지도교수
		ON 학생.학번 = 지도교수.학번
```

### full outer join (전체 외부 조인)
어느 한쪽에도 해당 사항이 없을 때는 전체 외부 조인

## 교차조인
### cross join
수학적 관점에서 봤을 때 데카르트 곱 cartesian product 이라고하는 곱집합 개념으로,
조인에 참여하는 테이블에서 발생할 수 있는 모든 조합을 찾아내어 반환

교차 조인을 명시적으로 작성한 SQL문
CROSS JOIN 키워드만으로 두 테이블을 조건 없이 연결하는 조인이 수행됨
```sql
SELECT 학생.학번, 학생.이름,
	지도교수.학번, 지도교수.교수명
	FROM 학생
	CROSS JOIN 지도교수
```

암시적 교차 조인을 작성한 SQL문
```sql
SELECT 학생.학번, 학생.이름,
	지도교수.학번,지도교수.교수명
	FROM 학생, 지도교수
```

## 자연조인
natural join
2개 테이블 동일한 열명이 있을 때 조인 조건절을 따로 작성하지 않아도 자동으로 조인을 수행해주는 방식 조인이 제대로 성사되면 내부 조인과 동일한 결과가 출력됨
이때 조인하는 열들의 데이터 유형이 서로 달라도 자연 조인이 수행됨
자연조인을 의도하고 명시적으로 작성해야 할 키워드는 NATURAL JOIN
SQL문에 ON 학생.학번 = 지도교수.학번과 같은 구문을 입력하면 에러가 발생함
```sql
SELECT 학생.*, 지도교수.*
	FROM 학생
	NATURAL JOIN 지도교수
```
 학생 테이블과 지도교수 테이블에 동일하게 존재하는 학번 열을 토대로 조인되었음을 확인이 가능함
학생 테이블과 지도교수 테이블에 공통으로 존재하는 열명이 하나도 없다면 학생 테이블과 지도교수 테이블에 동일한 열명이 없는 상태라면 발생 가능한 경우의 수를 모두 조합하는 교차 조인으로 수행됨

## 조인 알고리즘 용어
다수의 테이블에서 조인을 수행할 때는 동시에 여러 개의 테이블에 접근할 수 없는 만큼 접근하는 우선순위를 정하게 됨
다수의 테이블에서 첫 번째로 접근할 테이블, 두 번째로 접근할 테이블, 세 번째로 접근할 테이블 등 내부적으로 순번을 정하고, 차례대로 테이블에 접근한 결과를 다음 순번의 테이블로 전달함

### 드라이빙 테이블과 드리븐 테이블
driving table과 driven table
```sql
SELECT 학생.학번, 학생.이름,
	비상연락망.관계, 비상연락망.연락처
	FROM 학생
	JOIN 비상연락망
	ON 학생.학번 = 비상연락망.학번
	WHERE 학생.학번 IN (1, 100)
```
학생.학번 IN (1, 100) 조건이 있으므로 학생 테이블의 데이터를 먼저 찾아볼 것임
학생 테이블에서 찾은 결과로 비상연락망 테이블에서 학번 1과 100을 검색함
학생 / 비상연락망이라는 2개 테이블로 분리된 데이터에서 원하는 결과를 추려 결합하는 조인을 수행할 때, 테이블에 동시 접근할 수는 없으므로 테이블의 데이터에 접근하는 우선순위가 존재함.
먼저 접근하는 테이블인 드라이빙 테이블(= outer table)은 학생테이블이며 /
그 학생 테이블 검색결과를 통해 뒤늦게 데이터를 검색하는 테이블인 드리븐 테이블(= inner table)은 비상연락망 테이블입니다.

드라이빙 테이블에서 많은 건수가 반환되면
해당 결과를 가지고 드리븐 테이블에 접근하게 되는 만큼 사실상 드라이빙 테이블을 무엇으로 선정할지는 매우 중요한 문제임
가능하면 적은 결과가 반환될 것으로 예상되는 드라이빙 테이블을 선정하고, 조인 조건절의 열이 인덱스로 설정되도록 구성해야함

### 중첩 루프 조인 (NL 조인)
(nested loop join)은 들아ㅣ빙 테이블의 데이터 1건당 드리븐 테이블을 반복해 검색하며 최종적으로는 양쪽 테이블에 공통된 데이터를 출력함.
중첩 루프 조인의 특성을 알아보고자 몇 가지 조건을 기준으로 중첩 루프 조인을 수행할 예정

기본 키와 인덱스가 없는 두 테이블이 존재하는 상황에서 다음과 같은 SQL문으로 극단적인 중첩 루프 조인을 수행함
```sql
SELECT 학생.학번, 학생.이름,
	비상연락망.관계, 비상연락망.연락처
	FROM 학생
	JOIN 비상연락망
	ON 학생.학번 = 비상연락망.학번
	WHERE 학생.학번 IN (1, 100)
```
![[IMG_0318.jpeg]]인덱스는 인덱스로 정의된 열 기준으로 순차 정렬되지만, 인덱스를 이용해 테이블의 데이터를 찾아가는 과정에서 임의 접근 방식인 random access가 바생함
따라서 랜덤 액세스를 줄일 수 있도록 데이터의 액세스 범위를 좁히는 방향으로 인덱스를 설계하고 조건절을 작성해야함

랜덤 액세스를 유발하는 인데스는 기본 키가 아닌 비고유 인덱스일 경우에 해당함
기본 키는 클러스터형 인데스이므로 기본 키의 순서대로 테이블의 데이터가 적재되어 있어 조회 효율이 매우 높음

### 블록 중첩 루프 조인 (BNL 조인)
block nested loop join 은  드라이빙 테이블의 데이터 1건당 드리븐 테이블을 반복해 검색하며 최종적으로 양쪽 테이블에 공통된 데이터를 출력함
중첩 루프 조건의 특성

- 기본 키와 인덱스가 없는 두 테이블이 존재하는 상황에서 다음과 같은 SQL 문으로 극단적인 중첩 루프 조인 수행
학생 테이블이 드라이빙 테이블이고 비상연락망 테이블은 인데스 없이 생성되어 있다고 가정
이때 중첩 루프조인을 수행하면
학생 인덱스로 학번 1번을 찾은 뒤, 인덱스가 없는 비상연락망 테이블의 전체 데이터에 모두 접근해야할 것임
이후 학생 테이블에서 학번 100데이터를 찾고, 또 다시 비상 연락망 테이블은 전체데이터 1,000건에 접근함
인덱스가 없는 드리븐 테이블에 대해 매번 전체 데이터를 비효율적으로 검색하게 됨

중첩 루프 조인의 효율성을 높이고자 탄생한 것이 바로 블록 중첩 루프 조인
드라이빙 테이블에 대해 join buffer(조인 버퍼)라는 개념을 도입하고 조인 성능의 향상을 꾀할 수 있음

BNL 조인이 수행되는 저차
> 1. 드라이빙 테이블인 학생 테이블에서 학번 1과 100에 해당하는 데이터를 검색
> 검색된 데이터를 0 (조인버퍼)에 가득 채워질때까지 적재
> 0 조인 버퍼와 비상연락망 테이블의 데이터를 비교함
> 0 조인 버퍼와 2 데이터를 조인하고 
> 다시 0 조인 버퍼와 3 데이터를 조인하는 식으로 반복하여 비상연락망 데이터에 모두 접근함
> 조인 버퍼의 데이터들과 비상연락망 테이블의 한 번의 테이블 풀 스캔으로 원하는 데이터를 모두 찾을 수 있음

이 방법은 비상연락망 테이블 풀 스캔으로 원하는 데이터를 모두 찾을 수 있음 이 과정은 비상연락망 테이블의 테이블 풀 스캔을 줄이는게 목적으로, 성능 저하를 개선하는 조인 알고리즘 방식임

블록 해시 조인 (block hash join)이라는 방식도 있지만 블록 중첩 루프 조인 방식과 매우 유사하므로 설명 x 
이 방식은 조인 버퍼에 쌓인 데이터에 대해 해시값을을 적용하고 그 값을 기준으로 비상연락망 테이브로가 조인을 수행한다는 점이 다름

## 배치 키 액세스 조인 (BKA 조인)
batched key access join
중첩 루프 조인 방식은 필연적으로 데이터 접근 시 인데스에 의한 랜덤 액세스가 발생하므로,
액세스할 데이터의 범위가 넓다면 분명 비효율적인 조인 방식임
랜덤 액세스의 단점을 해결하고자 접근할 데이터를 미리 예상하고 가져오는 데 착안한 조인 알고리즘을 배치 키 액세스조인이라고 함

BKA 조인은 블록 중첩 루프 조인에서 활용한 드라이빙 테이블의 조인 버퍼 개념을 그대로 사용함
그리고 드리븐 테이블에 필요한 데이터를 미리 예측하고
정렬된 상태로 담는 랜덤 버퍼의 개념을 도입함

이때 드리븐 테이블의 데이터를 예측하고 정렬된 상태로 버퍼에 적재하는 기능을 multi range read(다중 범위 읽기)(MRR) 라고 함
미리 예측된 데이터를 가져와 정렬된 상태에서 랜덤 버퍼에 담기 때문에, 드리븐 테이블에 대해 랜덤 액세스가 아닌 시퀀셜 액세스를 수행하는 방식임
> 1 드라이빙 테이블에서 필요한 데이터를 추출하여 조인 버퍼에 적재 (학번이 1과 100인 데이터가 저장됨)
> 2 드리븐 테이블의 인덱스 기반으로 필요한 데이터를 예측하여 랜덤 버퍼에 적재하고
> 마찬가지로 학번 1과 100 데이터를 랜덤 버퍼인 메모리상에 상주시킴
> 3 학생.학번 = 비상연락망.학번에 대해 조인 조건절로 비교함
> 동일한 데이터가 있다고 판단되면 4 드리븐 테이블의 데이터에 접근하고 결과를 조인하여 반환함

## 해쉬 조인
hash join은 기존의 중첩 루프 조인 방식에서 조금 개선된 버전인 블록 중첩 루프 조인과 배치 키 액세스 조인의 한계를 탈피하는 시발점임
MySQL, MariaDB 에선 block nested loop hash (중첩 루프 해시) 라는 이름으로 해시 조인 기능을 제공중
해시 조인은 선후 관계를 두고 조인을 수행하는 중첩 루프 조인 방식과 달리, 조인에 참여하는 각 테이블의 데이터를 내부적으로 해시값으로 만들어 내부 조인을 수행함
해시 값으로 내부 조인을 수행한 결과는 조인 버퍼에 저장되므로 조인열의 인덱스를 필수로 요구하지 않아도 됨

| 학생테이블   | 조인버퍼           | 비상연락망 테이블    |
| ------- | -------------- | ------------ |
| 1- 이순신  | data:1 Hash #1 | 1- 이순신 아버지   |
|         | data:1 Hash #2 | 1- 이순신 어머니   |
| 2- 신사임당 | data:2         | 2- 신사임당 할아버지 |
| ...     | ...            | ...          |

이와 같은 해시 조인은 보통 대용량 데이터의 동등 비교 연산에서 확인할 수 있지만 아직까진 핵심적인 조인 알고리즘으로 처리되지 못하고 있음
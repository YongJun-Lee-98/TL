실행 계획은 SQL문으로 요청한 데이터를 어떻게 불러올 것인지에 관한 계획, 즉 경로를 의미함
지름길을 사용해 데이터를 빠르게 찾아낼 것인지, 지름길이 있어도 멀리 돌아가서 찾을 것인지 미리 확인이 가능함

## 기본 실행 계획 수행
### 실행 계획 키워드
EXPLAIN, DESCRIBE, DESC 가 있음
> EXPLAIN SQL 문;
> DESCRIBE SQL 문;
> DESC SQL 문;

임의의 SQL문에 관한 실행계획을 확인

#### MySQL
SQL문 앞에 EXPLAIN 키워드를 입력하고 실행하면 옵티마이저가 만든 실행 계획이 출력됨
EXPLAIN 대신 DESCRIBE나 DESC 키워드를 입력해도 됨
MariaDB에 비해 partitions, filtered 열이 추가되면서 더 많은 정보를 보여줌
```mysql
mysql > EXPLAIN
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 100001 AND 200000;
```

#### MariaDB
SQL문 앞에 EXPLAIN, DESCRIBE, DESE 키워드를 입력하면됨
UPDATE 및 DELETE 문에서도 실행 계획을 확인이 가능함
```sql
EXPLAIN
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 100001 AND 200000;
```

출려되는 정보에는 차이가 있지만, 실행 계획을 해석하고 SQL 튜닝을 수행하는 과정 자체에는 크게 영향을 주지 않음

## 기본 실행 계획 항목 분석
출력되는 항목의 의미를 이해해야함
SQL 문이 비효율적으로 수행되지는 않는지, 튜닝을 어떻게 해야할지 등에 관한 방향을 잡도록하낟.
### id
실행 순서를 표시하는 숫자, SQL문이 수행되는 차례를 ID로 표기한 것으로, 조인할 때는 똑같은 ID가 표시됨
ID의 숫자가 작을 수록 먼저 수행된 것이고 ID가 같은 값이라면 두 개 테이블의 조인이 이루어졌다고 해석이 가능함

ID가 1인 첫 번째 행과 두 번째 행의 조인이 이루어진 뒤에 세번째 행이 수행된 것이라고 짐작이 가능함

### select_type
SQL문을 구성하는 SELECT 문의 유형을 출력하는 항목
SELECT 문이 단순히 FROM 절에 위치한 것인지, 서브쿼리인지, UNION 절로 묶인 SELECT 문인지 등의 정보를 제공함

#### | SIMPLE |
UNION이나 내부 쿼리가 없는 SELECT 문이라는 걸 의미하는 유형
말 그대로 단순한 SELECT 구문으로만 작성된 경우를 가리킴

#### | PRIMARY |
서브쿼리가 포함된 SQL 문이 있을 때 첫 번째 SELECT 문에 해당하는 구문에 표시되는 유형
서브 쿼리를 감싸는 외부 쿼리이거나, UNION이 포함된 SQL 문에서 첫 번째로 SELECT 키워드가 작성된 구문에 표시됨

> |PRIMARY|~~~ | const | PRIMARY |
> |SUBQUERY| ~~~ | index | NULL |
> 
> ---

| key      | key_len | ref   | rows   | filtered | Extra       |
| -------- | ------- | ----- | ------ | -------- | ----------- |
| PRIMARY  | 4       | const | 1      | 100.00   | NULL        |
| 인덱스_부서번호 | 16      | NULL  | 331143 | 100.00   | Using index |

UNION ALL 구문으로 통합된 SQL 문에서
처음 SELECT 구문이 작성된 쿼리가 먼저 접근한다는 의미로 PRIMARY가 출력됨

```sql
EXPLAIN
SELECT 사원1.사원번호, 사원1.이름, 사원1.성
FROM 사원 as 사원1
WHERE 사원1.사원번호 = 100001

UNION ALL

SELECT 사원2.사원번호, 사원2.이름, 사원2.성
FROM 사원 as 사원2
WHERE 사원2.사원번호 = 100002;
```

#### | SUBQUERY |
독립적으로 수행되는 서브쿼리를 의미함.
다음 예제에서는 메인쿼리의 SELECT 절에 정의된 부서사원_매핑 테이블과 급여 테이블에 대해 옵티마이저가 서브쿼리임을 인지하고 있음을 알 수 있음
SELECT 절의 스칼라 서브쿼리와 WHERE 절의 중첩 서브쿼리일 경우에 해당
```sql
EXPLAIN
SELECT (SELECT COUNT(*)
	   FROM 부서사원_매핑 as 매핑) as 카운트,
	   (SELECT MAX(연봉)
	   FROM 급여) as 급여;
```

| id  | select_type | table | partitions | type  | possible_keys | key    |
| --- | ----------- | ----- | ---------- | ----- | ------------- | ------ |
| 1   | PRIMARY     | NULL  | NULL       | NULL  | NULL          | NULL   |
| 3   | SUBQUERY    | 급여    | NULL       | ALL   | NULL          | NULL   |
| 2   | SUBQUERY    | 매핑    | NULL       | index | NULL          | I_부서번호 |

| key_len | ref  | rows    | filtered | Extra          |
| ------- | ---- | ------- | -------- | -------------- |
| NULL    | NULL | NULL    | NULL     | No tables used |
| NULL    | NULL | 2838731 | 100.00   | NULL           |
| 12      | NULL | 331143  | 100.00   | Using index    |
#### | DERIVED |
FROM 절에 작성된 서브쿼리라는 의미
즉, FROM 절의 별도 임시 테이블인 인라인 뷰를 말함
다음 쿼리는 메인쿼리의 FROM 절에서 급여 테이블의 데이터를 가져오는 인라인 뷰임
해당 인라인 뷰는 실행 계획을 통해 두 번째로 수행되고 있다는 걸 알 수 있음

#### | UNION |
UNION 및 UNION ALL 구문으로 합쳐진 SELECT 문에서 첫 번째 SELECT 구문을 제외한 이후의 SELECT 구문에 해당한다는 걸 나타냄
이때 UNION 구문의 첫 번째 SELECT 절은 PRIMARY 유형으로 출력됨
```sql
EXPLAIN
SELECT 'M' as 성별, MAX(입사일자) as 입사일자
	FROM 사원 as 사원1
WHERE 성별 = 'M'

UNION ALL

SELECT 'F' as 성별 MIN(입사일자) as 입사일자
	FROM 사원 as 사원2
WHERE 성별 = 'F';
```
#### | UNION RESULT |
UNION ALL이 아닌 UNION 구문으로 SELECT 절을 결합했을 때 출력됨
각 SELECT절에서 데이터를 가져와 정렬하여 중복 체크하는 과정을 거침
따라서 UNION RESULT는 별도의 메모리 또는 디스크에 임시 테이블을 만들어 중복을 제거하겠다는 의미로 해석이 가능
한편 UNION 구문으로 결합되기 전의 각 SELECT 문이 중복되지 않는 결과가 보장될 때는 UNION 구문보다는 UNION ALL 구문으로 변경하는  SQL 튜닝을 수행함

```sql
EXPLAIN
SELECT 사원_통합.*
	FROM(
		SELECT MAX(입사일자) as 입사일자
		FROM 사원 as 사원1
		WHERE 성별 = 'M'
		UNION
		SELECT MIN(입사일자) as 입사일자
		FROM 사원 as 사원2
		WHERE 성별 = 'M'
	) as 사원_통합;
```

#### | DEPENDENT SUBQUERY |
UNION 또는 UNION ALL 을 사용하는 서브쿼리가 메인 테이블의 영향을 받는 경우
UNION으로 연결된 단위 쿼리들 중에서 처음으로 작성한 단위 쿼리에 해당되는 경우
즉, UNION으로 연결되는 첫 번째 단위 쿼리가 독립적으로 수행하지 못하고 메인 테이블로부터 값을 하나씩 공급받는 구조 (AND 사원1.사원번호 = 관리자.사원번호)이므로 성능적으로 불리하여 SQL 문이 튜닝 대상이 됨

#### | DEPENDENT UNION |
UNION 또는 UNION ALL을 사용하는 서브쿼리가 메인 테이블의 영향을 받는 경우로 UNION으로 연결된 단위 쿼리 중 첫 번째 단위 쿼리를 제외하고 두 번째 단위 쿼리에 해당하는 경우
UNION으로 연결되는 두 번째 이후의 단위 쿼리가 독립적으로 수행하지 못하고 메인 테이블로부터 값을 하나씩 공급받는 구조 (AND 사원2.사원번호 = 관리자.사원번호)이므로 성능적으로 불리하여 SQL문의 튜닝 대상이 된다.

실행 계획의 가독성을 높이고자 ref, rows, filtered,, Extra 정보는 생략합니다.
다음 SQL 문과 실행 계획은 앞에서 소개한 DEPENDENT SBUQUERY와 동일한 예제
```sql
EXPLAIN
SELECT 관리자.부서번호,
	( SELECT 사원1.이름
		FROM 사원 AS 사원1
		WHERE 성별 = 'F'
		AND 사원1.사원번호 = 관리자.사원번호
		
		UNION ALL
		
		SELECT 사원2.이름
		FROM 사원 AS 사원2
		WHERE 성별 = 'M'
		AND 사원2.사원번호 = 관리자.사원번호
		) AS 이름
	FROM 부서관리자 AS 관리자;
```
#### | UNCACHEABLE SUBQUERY |
말 그대로 메모리에 상주하여 재활용되어야 할 서브쿼리가 재사용되지 못할 때 출력되는 유형
이러한 유형은 
1) 해당 서브쿼리 안에 사용자 정의함수나 사용자 변수가 포함되거나
2) RAND(), UUID() 함수등을 사용하여 매번 조회 시마다 결과가 달라지는 경우에 해당
만약 자주 호출되는 SQL문 이라면 메모리에 서브쿼리 결과가 상주할 수 있도록 변경하는 방향으로 SQL 튜닝을 검토해볼 수 있음. 여기서도 실행 계획의 가독성을 높이고자 possible_keys, key, key_len, ref 정보는 생략함

다음 RAND() 함수는 0~1사이의 소수점 기준으로 17자리 숫자를 출력(예. 0.2184567844670694)하는 함수
앞에서 설명한 대로 매번 출력값이 달라지는 RAND() 함수 때문에 서브쿼리(SELECT ROUND (RAND() * 1000000))는 메모리에 캐시되지 못함

#### | MATERIALIZED |
IN 절 구문에 연결된 서브쿼리가 임시 테이블을 생성한 뒤, 조인이나 가공 작업을 수행할 때 출력되는 유형입니다. 즉, IN 절의 서브쿼리를 임시 테이블로 만들어서 조인 작업을 수행하는 것
다음 SQL 문에서는 IN 절 구문의 서브쿼리 (SELECT 사원번호 FROM 급여 WHERE 시작일자>'2020-01-01')가 임시테이블을 생성하고, 이후 사원 테이블과 조인을 수행함을 확인할 수 있음
실행 계획의 가독성을 높이고자 possible_keys, key, key_len, ref 정보는 생략

```sql
EXPLAIN
SELECT *
	FROM 사원
	WHERE 사원번호 IN (SELECT 사원번호 FROM 급여 WHERE 시작일자>'2020-01-01');
```


### table
말 그대로 테이블 명을 표시하는 항목
실행 계획 정보에서 테이블명이나 테이블 별칭alias를 출력하며, 
서브쿼리나 임시 테이블을 만들어서 별도의 작업을 수행할 때는 
<subquery#>나 <derived#>라고 출력됨

ID 값의 비교로 ID값이 같은 것은 위에 존재하는 테이블에 아래 존재하는 테이블이 join했다는 것으로 해석할 수 있다.
<drived 2> 인경우 ID가 2인 테이블을 참조 했다는 것을 알 수 있음


### partitions
실행 계획의 부가 정보로, 데이터가 저장된 논리적인 영역을 표시하는 항목
사전에 정의한 전체 파티션 중 특정 파티션에 선택적으로 접근하는 것이 SQL 성능 측면에서 유리함
너무 많은 영역의 파티션에 접근하는 것으로 출력된다면 파티션 정의를 튜닝해봐야 할 것임

### type
테이블의 데이터를 어떻게 찾을지에 관한 정보를 제공하는 항목
테이블을 처음부터 끝까지 전부 확인할지 아니면 인덱스를 통해 바로 데이터를 찾아갈지 등을 해석할 수 있음
#### |system|
테이블에 데이터가 없거나 한 개만 있는 경우로, 성능상 최상의 type이라고 할 수 있음

#### |const|
조회되는 데이터가 단 1건 일때 출력되는 유형으로, 성능상 매우 유리한 방식
고유 인덱스나 기본 키를 사용하여 단 1건의 데이터에만 접근하면 되므로 속도나 리소스 사용 측면에 서 지향해야 할 타입

#### |eq_ref|
조인이 수행될 때 드리븐 테이블의 데이터에 접근하며 고유 인덱스 또는 기본 키로 단 1건의 데이터를 조회하는 방식 드라이빙 테이블과의 조인 키가 드리븐 테이블에 유일하므로 조인이 수행될 때 성능상 가장 유리한 경우라고 할 수 있음

먼저 작성된 첫 번째 행의 부서사원_매핑 테이블이 드라이빙 테이블이고, 이후 출력되는 두 번째 행의 부서 테이블이 드리븐 테이블인 것으로 해석됨
type 우형이 eq_ref로 출력 되었으므로 조인 수행시 기본 키나 고유 인덱스를 활용하여 1건의 데이터씩만 검색되는 과정을 미리 확인할 수 있음

#### |ref|
앞에서 설명한 eq_ref유형과 유사한 방식으로, 조인을 수행할 때 드리븐 테이블의 데이터 접근 범위가 2개 이상일 경우를 의미함.
즉 드라이빙 테이블과 드리븐 테이블이 조인을 수행하면 일대다 관계가 되므로, 드라이빙 테이블의 1개 값이 드리븐 테이블에서는 2개 이상의데이터로 존재함
기본 키나 고유 인덱스를 활용하면 2개 이상의 데이터가 검색되거나 유일성이 없는 비고유 인덱스를 사용하게 됨
드리븐 테이블의 데이터 양이 많지 않을때는 성능 저하를 크게 우려하지 않아도 되지만, 데이터 양이 많다면 접근해야할 데이터 범위가 넓어져 성능 저하의 원인이 되는지 확인해야함.
한편으로는 =,<,>등의 연산자를 사용해 인덱스로 생성된 열을 비교할 때도 출력됨

사원 테이블과 직급 테이블의 조인을 수행하는 예제로, 1건의 사원 데이터 대비 여러개의 직급 데이터가 조회될 수 있는 구조임. 따라서 드라이빙 테이블인 사원테이블의 사원번호를 조인키로 삼아 직급 테이블의 데이터에 접근하지만, 하나의 사원번호당 다수의 딪급 데이터가 조회되리라고 짐작할 수 있음

#### |ref_or_null|
ref 유형과 유사하지만 IS NULL 구문에 대해 인덱스를 활용하도록 최적화된 방식
MySQL과 MariaDB는 NULL에 대해서도 인덱스를 활용하여 검색할 수 있으며, 이때 NULL은 가장 앞쪽에 정렬됨
테이블에서 검색할 NULL 데이터양이 적다면 ref_of_null 방식을 활용했을 때 효율적인 SQL문이 될 것이나, 검색할 NULL 데이터 양이 많다면 SQL 튜닝의 대상이 될 것임

#### |range|
테이블 내의 연속된 데이터 범위를 조회하는 유형으로 =,<,>,>=,<=, IS NULL, <=>, BETWEEN 또는 IN 연산자를 통해 범위 스캔을 수행하는 방식, 주어진 데이터 범위 내에서 행단위로 스캔하지만, 스캔할 범위가 넓으면 성능 저하의 요인이 될 수 있으므로 SQL 튜닝 검토 대상이 됨

#### |fulltext|
텍스트 검색을 빠르게 처리하기 위해 전문 인덱스 full text index를 사용하여 데이터에 접근하는 방식

#### |index_merge|
말 그대로 결합된 인덱스들이 동시에 사용되는 유형.
즉, 특정 테이블에 생성된 두 개 이상의 인덱스가 병합되어 동시에 적용됨 이때 전문 인덱스는 제외됨
가독성을 고려하여 당장 필요하지 않은 partitions, possible_keys, filtered 정보는 설명하지 않음
사원 테이블으 ㅣ입사일자 열에 대해 인덱스_입사일자 인덱스와 사원번호 열로 구성된 기본 키 모두를 통합해서 사용하리라 예측할 수 잇음

#### |index|
type 항목의 index 유형은 인덱스 풀 스캔을 의미함
즉, 물리적인 인덱스 블록block을 처음부터 끝까지 훑는 방식을 말함
이때 데이터를 스캔하는 대상이 인덱스라는 점ㄴ이 다를뿐, 이어서 설명할 ALL 유형(테이블 풀 스캔 방식)과 유사함
인덱스는 보통 테이블보다 크기가 작으므로 테이블 풀 스캔 방식보다는 빠를 가능성이 높음

#### |ALL|
테이블을 처음부터 끝까지 읽는 테이블 풀 스캔 방식에 해당되는 유형
ALL 유형은 활용할 수 있는 인덱스가 없거나, 인덱스를 활용하는 게 오히려 비효율적이라고 옵티마이저가 판단했을 때 선택됨
ALL 유형일 때는 인덱스를 새로 추가하거나 기존 인덱스를 변경하여 인덱스를 활용하는 방식으로 SQL 튜닝을 할 수 있으나 전체 테이블 중 10~20% 이상 분량의 데이터를 조회할 때는 ALL 유형이 오히려 성능상 유리할 수 있음

### possible_keys
옵티마이저가 SQL문을 최적화하고자 사용할 수 있는 인덱스 목록을 출력함
다만 실제 사용한 인덱스가 아닌, 사용할 수 잇는 후보군의 기본 키와 인덱스 목록만 보여주므로 SQL 튜닝의 효용성은 없습니다.

### key
옵티마이저가 SQL 문을 최적화하고자 사용한 기본 키 (PK) 또는 인덱스명을 의미합니다. 어느 인덱스로 데이터를 검색했는지 확인할 수 있으므로, 비효율적인 인덱스를 사용했거나 인덱스 자체를 사용하지 않았다면 SQL 튜닝의 대상이 됨

SQL문의 key 열을 확인할 때 값이 NULL로 확인되는 것은 기본 키와 인덱스를 전혀 사용하지 않았다는 뜻

### key_len
인덱스를 사용할 때는 인덱스 전체를 사용하거나 일부 인덱스만 사용합니다.
key_len은 이렇게 사용한 인덱스의 바이트 수를 의미함
UTF-8 캐릭터셋 기준 INT 데이터 유형은 단위당 4바이트 VARCHAR 데이터 유형은 단위당 3바이트임을 인지하고 key_len을 이해하기
key 열은 PRIMARY로 확인되며 key_len은 159 바이트로 확인된 경우
SQL문은 WHERE 절에서 직급명을 사용하여 사원번호의 데이터를 조회하고 있음
사원번호 + 직급명 + 시작일자 열들로 구성된 PK를 어떻게 활용했는지 확인이 가능
사원번호 - INT 유형으로 4바이트에 해당
직급명 - varchar(50) 데이터 유형으로 (50+1) x 3 바이트
즉, PK에서 사원번호의 4바이트와 직급명 155바이트만 사용해서 key_len이 159바이트로 출력됨을 알 수있음

### ref
reference의 약자로 테이블 조인을 수행할 때 어떤 조건으로 해당 테이블에 액세스되었는지를 알려주는 정보임
2개 행의 id가 똑같이 1로 출력된 경우 사원 테이블과 직급 테이블의 조인을 수행하였음을 알 수 있음
드리븐 테입ㄹ인 직급 테이블의 데이터에 접근하면 사원번호로 데이터를 검색한다는 걸 확인할 수 있음
WHERE 절의 사원.사원번호 = 직급.사원번호를 통해서도 이미 짐작할 수 있는 부분

### rows
SQL문을 수행하고자 접근하는 데이터의 모든 행 수를 나타내는 예측 항목임
디스크에서 데이터 파일 읽고 메모리에서 처리해야 할 행 수를 예상하는 값
수시로 변동되는 MySQL의 통계 정보를 참고하여 산출하는 값이므로 수치가 정확하진 않음
그리고 최종 출려될 행 수가 아니라는 점에 유의해야함

SQL문의 최종 결과 건수와 비교해 rows 수가 크게 차이 날 때는 불필요하게 MySQL엔진까지 데이터를 많이 가져왔다는 뜻이므로 SQL 튜닝의 대상이 될 수 있음

### filtered
SQL 문을 통해 DB 엔진으로 가져온 데이터 대상으로 필터 조건에 따라 어느 정도의 비율로 데이터를 제거했는지를 의미하는 항목. 예를 들어 DB 엔진으로 100건의 데이터를 가져왔다고 가정한다면, 이후 WHERE 절의 사원번호 between 1 and 10 조건으로 100건의 데이터가 10건으로 필터링 됨
100건에서 10건으로 필터링 되었으므로 filtered에는 10이라는 정보가 출력될 것임 이때 단위는 %임

### extra
SQL문을 어떻게 수행할 것인지에 관한 추가 정보를 보여주는 항목
부가적인 정보들은 세미콜론(;)으로 구분하여 여러 가지 정보를 나열할 수 있으며 30여 가지 항목으로 정리할 수 있음
일반적인 예제에서 자주 발생하고, 현업에서도 자주 만나게 될 몇 가지 extra 정보만 설명함
MySQL에서는 extra에서 수행되는 정보가 모두 출력되지는 않으므로 어디까지나 참고하는 수준에서 해석하는 것이 좋음

#### |Distinct|
중복이 제거되어 유일한 값을 찾을 때 출력되는 정보.
중복 제거가 포함되는 distinct 키워드나 union 구문이 포함된 경우 출력됨

#### |Using where|
실행 계획에서 자주 볼 수 있는 extra 정보.
WHERE 절의 필터 조건을 사용해 MySQL 엔진으로 가져온 데이터를 추출할 것이라는 의미로 이해할 수 있음

#### |Using temporary|
데이터의 중간 결과를 저장하고자 임시 테이블을 생성하겠다는 의미
데이터를 가져와 저장한 뒤에 정렬 작업을 수행하거나 중복을 제거하는 작업 등을 수행함
보통 DISTINCT, GROUP BY, ORDER BY 구문이 포함된 경우 Using temporary 정보가 출력됨

임시 테이블을 메모리에 생성하거나, 메모리 영역을 초과하여 디스크에 임시 테이블을 생성하면 Using temporary는 성능 저하의 원인이 될 수 있음
따라서 이 항목의 정보가 출력되는 쿼리는 SQL 튜닝의 대상이 될 수 있음

#### |Using index|
물리적이 데이터 파일을 읽지 않고 인덱스만을 읽어서 SQL문의 요청사항을 처리할 수 있는 경우를 의미함
커버링 인덱스 covering index 방식이라고 부르며, 인덱스로 구성된 열만 SQL 문에서 사용할 경우 이 방식을 활용함
물리적으로도 테이블보다 인덱스가 작고 정렬되어 있으므로 적은 양의 데이터에 접근할 때 성능 측면에서 효율적임
직급 테입르 기본키 - 사원번호, 직급명, 시작일자
WHERE 절에서는 사원번호를, SELECT 절에서는 직급명을 조회하므로 그 외의 다른 열은 필요하지 않음
따라서 기본 키만 활용해서 원하는 정보를 모두 가벼올 수 있는 커버링 인덱스 방식으로 데이터에 접근

#### |Using filesort|
정렬이 필요한 데이터를 메모리에 올리고 정렬 작업을 수행한다는 의미 보통 이미 정렬된 인덱스를 사용하면 추가적인 정렬 작업이 필요 없지만, 인덱스를 사용하지 못할 때는 정렬을 위해 메모리 영역에 데이터를 올리게 됨
Using filesort는 추가적인 정렬작업이므로 인덱스를 활용하도록 SQL 튜닝 검토대상이 될 수 있음

#### |Using join buffer|
조인을 수행하기 위해 중간 데이터 결과를 저장하는 조인 버퍼를 사용한다는 의미
즉, 드라이빙 테이블의 데이터에 먼저 접근한 결과를 조인 버퍼에 담고 난 뒤, 조인 버퍼와 드리븐 테이블 간에 서로 일치하는 조인 키값을 찾는 과정을 수행함 이러한 조인 버퍼를 활용하는 일련의 과정이 존재하면 Using join buffer 정보가 출력됨

#### |Using union/ Using intersect/ Using sort_union|
앞서 실행 계획의 type 항목에서는 두 개 이상의 인데스가 병합되어 데이터에 접근하는 경우를 나타내는 index_merge 유형을 설명했음. 이처럼 인덱스가 병합되어 실행되는 SQL문의 extra 항목에는 인덱스를 어떻게 병합했는지에 관한 상세 정보가 출력됨. 그 정보가 Using union, Using intersect, Using sort_union
##### Using union
인덱스들을 합집합처럼 모두 결합하여 데이터에 접근한다는 뜻
보통 SQL문이 OR 구문으로 작성된 경우에 해당
##### Using intersect
인덱스들을 교집합처럼 추출하는 방식으로 SQL문이 AND 구문으로 작성된 경우에 확인할 수있는 extra 정보
##### Using sort_union
기본적으로 Using union과 유사하지만 WHERE 절의 OR 구문이 동등조건이 아닐 때 확인할 수 있는 extra 정보
##### |Using index condition|
Mysql 엔진에서 인덱스로 생성된 열의 필터 조건에 따라 요청된 데이터만 필터링하는 Using where 방식과 달리
필터 조건을 스토리지 엔진으로 전달하여 필터링 작업에 대한 Mysql 엔진의 부하를 줄이는 방식이라고 이해하면 됨. 이는 스토리지 엔진의 데이터 결과를 Mysql엔진으로 전송하는 데이터양을 줄여 성능 효율을 높일 수 있는 옵티마이저의 최적화 방식

#### |Using index condiditon (BKA)|
type 정보의 Using index condition 유형과 비슷하나, 데이터를 검색하기 위해 배치 키 액세스를 사용하는 방식입니다.

#### |Using index for group-by|
SQL 문에 Group by 구문이나 Distinct 구문이 포함될 때는 인덱스로 정렬 작업을 수행하여 최적화합니다. 이때 Using index for group-by는 인덱스로 정렬 작업을 수행하는 인덱스 루스 스캔일 때 출력되는 부가정보임

|Not exists|
하나의 일치하는 행을 찾으면 추가로 행을 더 검색하지 않아도 될 때 출력되는 유형
해당 메커니즘은 왼쪽 외부 조인 또는 오른쪽 외부 조인에서 테이블에 존재하지 않는 데이터를 명시적으로 검색할 때 발생함
예를 들어 SELECT * FROM t1 LEFT JOIN t2 on (...) WHERE t2.not_null_column IS NULL; 이라는 SQL문에서 t1과 t2 테이블의 조건에 일치하는 데이터가 없는 경우에는 그 값이 NULL이 될 수 있으므로 일치하는 행을 하나 찾았으니 검색을 중지하게 됨 이 상황을 Not exists가 출력됨
![[Pasted image 20240830155548.png]]
## 확장된 실행 계획 수행
실행 계획을 확인하는 키워드로는 EXPLAIN을 사용하지만, 추가 정보를 확인하고자 한다면 DB에서 각각 지원하는 키워드를 입력할 수 있음
MySQL과 MariaDB에서 실행 계획 명령어가 서로 다르므로 다음과 같이 구분해서 실행한다.

### MySQL 확장 실행계획 수립
#### |EXPLAIN FORMAT = TRADITIONAL|
기본적인 실행 계획은 EXPLAIN 키워드로 입력하며 기본 포맷은 TRADITIONAL임
명시하지 않아도 기본적인 실행 계획 정보가 출력됨

```sql
EXPLAIN FORMAT = TRADITIONAL
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 100001 AND 200000;
```

#### |EXPLAIN FORMAT = TREE|
형식 값에 TREE 옵션을 입력하면 트리 형태로 추가된 실행 계획 항목을 확인할 수 있음
```sql
EXPLAIN FORMAT = TREE
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 10001 AND 200000;
```

#### |EXPLAIN FORMAT = JSON|
형식값에 JSON 옵션을 입력하면 JSON 형태로 추가된 실행 계획 항목을 확인할 수 있음
```sql
EXPLAIN FORMAT = JSON
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 100001 AND 200000;
```

#### |EXPLAIN ANALYZE|
그동안 출력된 실행 계획은 예측된 실행 계획에 관한 정보임
만약 실제 측정한 실행 계획정보를 출력하고 싶다면 ANALYZE 키워드를 사용함
실제 수행된 소요 시간과 비용을 측정하여 실측 실행 계획과 예측 실행 계획 모두를 확인하려면 EXPLAIN ANALYZE 키워드를 활용합니다.
MySQL 8.018이상에서는 SELECT문 대상으로 수행이 가능함
```sql
EXPLAIN ANALYZE
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 100001 AND 200000;
```


### MariaDB의 확장된 실행 계획 수행
#### |EXPLAIN PARTITIONS|
파티션으로 설정된 테이블에 대해 접근 대상인 파티션 정보를 출력함
```sql
EXPLAIN PARTITIONS
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 100001 AND 200000;
```

#### |EXPLAIN EXTENDED|
스토리 엔진에서 가져온 데이터를 다시 MySQL 엔진에서 추출한 비율인 filtered열의 값을 추가로 출력함
```sql
EXPLAIN EXTENDED
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 100001 AND 200000;
```

#### |ANALYZE|
MrriaDB 이상에서는 ANALYZE 키워드만으로 실제 측정한 실행 계획 정보가 출력됨
실제 액세스한 데이터 건수(r_rows)와 MySQL 엔진에서 가져온 데이터에서 추가로 추출한 데이터 비율(r_filtered)을 확인할 수 있음
```sql
ANALYZE
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 100001 AND 200000;
```

## 프로파일링
profiling은 마치 범죄수사에서 실마리를 찾으려고 분석하는 수단처럼 SQL문에서도 문제가 되는 병목 지점을 찾고자 사용하는 수단이나 툴을 가리킴
느린 쿼리 - slow query나 문제가 있다고 의심되는 SQL 문의 원인을 확인할 수 있음

확인하는 과정은 툴 이 아닌 명령줄 에서 수행됨
툴은 사용자의 의도와 무관하게 백그라운드에서 호출되는 SQL문이 존재하므로 예상치 않은 SQL문이 프로파일링 되지 않도록 명령줄을 활용할 것

### SQL 프로파일링 실행하기
실습 대상 DB에 접속한 뒤 프로파일링의 설정값을 확인함
MySQL은 기본적으로 비활성화 되어 있으므로 OFF로 되어 있다면 활성화 작업을 진행하여야함

```sql
show variables like 'profiling%';
```
SET 키워드로 프로파일링을 활성화 (ON) 상태로 변경하기
접속한 세션에 한해서만 적용되므로 다른 접속 세션에는 영향을 미치지 않음
```sql
set profiling = 'ON';
```
프로파일링을 수행할 SQL문을 출력함
```sql
SELECT 사원번호
FROM 사원
WHERE 사원번호 = 100000;
```
프로파일링을 활성화 한 뒤 프로파일링된 쿼리 목록을 확인함
Query_ID 값이 2인 쿼리가 프로파일링으로 확인할 대상임
```sql
show profiles;
```
특정 쿼리 ID에 대해서만 프로파일링된 상세내용을 확인하고자 한다면
쿼리 ID를 입력하여 다음과 같은 문법으로 결화를 확인함
```sql
show profile for query #
```
\#은 숫자
```sql
show profile for query 1;
```
실제 특정 Status에 해당 되는 Duration 값이 높게 나타난다면 문제가 될 소지가 높은 구간으로 볼 수 있음

